---
title: 前端面试题
date: 2020-06-20 17:44:19
tags: ['前端', '面试题']
---
### 写React/Vue项目时，为什么要在列表组件中写key，其作用是什么？
官网推荐使用key，应该理解为使用唯一的ID作为key，因为用index作为key和不带key的效果是一样的。index作为key时，每个列表在变更前后是一样的，都是直接判断sameVnode，然后复用。
key的作用就是更新组件时，判断两个节点是否相同。相同就复用，不相同就删除旧的，创建新的。
正是因为带有唯一的key，每次更新是都找不到唯可复用的节点，不但要销毁和创建vnode，在DOM里添加移除节点对性能影响更大。所以才会说：”不带key，可能性能更好“。
因为不带key时，节点能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM的文本内容，而不是移除/添加节点，这就是文档中所说的：”刻意依赖默认行为，以获取性能上的提升“。
既然如此，为什么还要建议带key呢？因为这种不带key的模式只适用于简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。
```
举个例子：
一个新闻列表，可以点击列表项来将其标记为已访问。可以通过tab切换到”娱乐新闻“或”社会新闻“。
不带key属性的情况，在”娱乐新闻“下选中第二项，然后切换到”社会新闻“，”社会新闻“里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上唯一的新闻id作为唯一的key，那么每次渲染列表时，都会完全替代所有的组件，从而拥有正确的状态。
```
这只是个简单的例子，实际应用汇更复杂。带上唯一的key，虽然会增加开销，但对于用户来说，基本感受不到差别，而且能保证组件状态的正确。这应该是为什么官方推荐使用唯一id作为key的原因。

### ['1','2','3'].map(parseInt)
```
[1, NaN, NaN]
Array.prototype.map() 创建一个新数组，其结果是该数组中每个元素都调用一次提供的函数后的返回值。
parseInt(string, radix) 将一个字符串string转换为radix进制的整数，radix介于2~36之间
模拟运行的情况：
1. parseInt('1', 0) // radix为0时，且string参数不以”0x“开头，按照10进制来处理，这个时候返回1
2. parseInt('2', 1) // radix介于2~36之间，无法解析该字符串，返回NaN
3. parseInt('3', 2) // 2进制表示的数中，最大值小于3，所以无法解析，返回NaN
```

### 什么是防抖和节流？有什么区别？如何实现？
1. 防抖
> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次触发，则重新计算事件
思路：
> 每次触发事件时，都会取消掉之前的延时调用方法
demo：
```
function debounce(fn) {
  let timer = null; // 创建一个标记，用来存放定时器的返回值
  return function () {
    clearTimeout(timer); // 把之前的timer移除
    timer = setTimeout(() => { // 创建新的timeout
      fn.apply(this, arguments)// 为了确保上下文环境为当前的this，不能直接使用fn();
    }, 300);
  }
}
function sayHi() {
  console.log('防抖成功');
}
let inp = document.querySelect('#inp');
inp.addEventListener('input', debounce(sayHi))
```
2. 节流
> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
思路：
> 每次触发事件时，都判断当前是否有等待执行的延时函数
demo:
```
function throttle(fn) {
  let canRun = true; // 通过闭包保存一个标记
  return function () {
    if (!canRun) {
      return;
    }
    canRun = false;
    setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
      fn.apply(this, arguments);// 为了确保上下文环境为当前的this，不能直接使用fn();
      canRun = true;// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
    }, 300)
  }
}
function sayHi(e) {
  console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```

### 介绍下Set、Map、WeakSet和WeakMap的区别？

名称 | 描述
--|--
Set | 1. 成员唯一，无状态且不重复； 2. 只有键值，没有键名，类似数组； 3. 可以遍历，方法有add、has、delete
WeakSet | 1. 成员都是对象； 2. 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不易造成内存泄漏； 3. 不能遍历，方法有add、has、delete
Map | 1. 本质上是键值对集合，类似集合； 2. 可以遍历，方法很多，可以跟跟中数据类型转换
WeakMap | 1. 只接受对象作为键名（null除外），不接受其他类型的值作为键名； 2. 键名是弱引用，键值可以是任意值，键名所指向的对象可以被垃圾回收，此时键名是无效的； 3. 不能遍历，方法有get、set、delete、has

1. Set
ES6新增的一种数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。
Set是一种叫做集合的数据结构
应用场景：数据重组
Set本身是一个构造函数，用来生成Set数据结构
```
new Set([literable])
const s = new Set();
[1, 2, 3, 4, 3, 2, 1].forEach(x => s.add(x));
for(let i of s) {
  console.log(i) // 1 2 3 4
}
// 数组去重
[...new Set([1, 2, 3, 4, 3, 2, 1])]
```
任意数据类型都可以作为Set对象的成员
Set内部判断两个值是否不同，使用的算法是”same-value-zero equality“，它类似于精确相等运算符（===），不同点：Set对象认为NaN等于自身，而精确相等运算符认为NaN不等于自身。
```
const set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // {NaN}
```
Set实例属性
> constructor 构造函数
> size 包含元素的数量
Set实例方法
> add(value) 新增元素
> delete(value) 存在即删除元素
> has(value) 判断集合中是否存在value
> clear() 清空集合中所有元素
Set对象与数组间的转换
```
const arr = [1, 2, 3, 4, 3, 2, 1]
const set1 = new Set(arr) // {1, 2, 3, 4}
Array.from(set1)  // [1, 2, 3, 4]
[...set1] // [1, 2, 3, 4]
```
遍历Set对象的方法
> keys() 返回一个集合中包含所有键的迭代器
> values() 返回一个集合中包含所有值得迭代器
> entries() 返回一个集合中包含所有键值对的迭代器
> forEach(callback, thisArg) 对于集合中的成员执行callback操作，没有返回值。设置thisArg，则当前的执行上下文环境就是thisArg
```
const set2 = new Set([1, 2, 3]);
console.log(set2.keys()); // SetIterator {1, 2, 3}
console.log(set2.values()); // SetIterator {1, 2, 3}
console.log(set2.entries()); // SetIterator {1 => 1, 2 => 2, 3 => 3}
for(let item of set2.entries()) {
  console.log(item); // [1, 1] [2, 2] [3, 3]
}
```
Set 很容易实现交集、并集、差集
```
let set3 = new Set([2, 3, 4]);
let set4 = new Set([2, 5, 4]);
let intersect = new Set([...set4].filter(x => set3.has(x))); // {2, 4}
let union = new Set([...set3, ...set4]); // {2, 3, 4, 5}
let difference = new Set([...set4].filter(x => !set3.has(x))); // {5}

```
2. WeakSet
WeakSet 允许将弱引用对象存到集合中
Set和WeakSet的区别：
> WeakSet只能存放对象，不能存其他值；而Set都可以存
> WeakSet里存的是弱引用对象，在没有其他变量或属性引用该对象的时候，会被垃圾回收机制回收。
> WeakSet是不可以遍历的，也就无法拿到集合中的所有元素。
WeakSet中的属性/方法
> constructor 构造函数
> add(value) 添加value
> has(value) 是否包含value
> delete(value) 删除value
> clear() 清空WeakSet中所有的元素，注意该方法已废弃
3. Map

类型 | 集合与字典
--|--
共同点 | 都可以存储不重复的值
不同点 | 集合是以[value,value]的形式存储元素，字典以[key, value]的形式存储元素

```
const m = new Map();
let obj = {p: 'nihao'}
m.set(obj, 'content')
m.get(obj) // content
m.has(obj)  // true
m.delete(obj) // true
m.has(obj)  // false
```
任何具有iterator接口，且每个成员都是一个双元素数组的数据结构，都可以当做Map构造函数的参数
```
let set5 = new Set([['foo', 1], ['bar', 2]]);
let map1 = new Map(set5);
map1 // {"foo" => 1, "bar" => 2}
map1.get('bar') // 2
let map2 = new Map([['baz', 3]]);
map2 // {"baz" => 3}
map2.get('baz') // 3 
```
注意：只有对同一个对象的引用，Map才将其视为同一个键名
```
let map3 = new Map();
map3.set([a], 4);
map.get([a]); // undefined
```
Map属性
> constructor 构造函数
> size 字典中包含元素的个数

Map操作方法
> get(key) 读取字典中键名key的数据，并返回
> set(key, value) 向字典中添加新元素
> delete(key) 通过键名key，移除对应的数据
> has(key) 判断字典中是否存在键名key的数据
> clear() 将字典中所有的元素删除

Map遍历方法
> keys() 将字典中包含的键名以迭代器形式返回
> values() 将字典中包含的键值以迭代器形式返回
> entries() 返回字典中所有成员的迭代器
> forEach(callback, thisArg) 遍历字典中所有成员
```
const map4 = new Map([['name', 'Jack'], ['desc', 'JS']]);
map4 // {"name" => "Jack", "desc" => "JS"}
map4.keys() // MapIterator {"name", "desc"}
map4.values() // MapIterator {"Jack", "JS"}
map4.entries() // MapIterator {"name" => "Jack", "desc" => "JS"}
```

4. WeakMap
WeakMap 是一组键值对的集合，键名弱引用对象，键值是任意数据
弱引用对象，在没有其他变量或属性引用的情况下，会被垃圾回收机制收回。
不可枚举
WeakMap属性/方法
> constructor 构造函数
> get(key) 读取键名key的对象，并返回
> set(key, value) 设置一组键名key的对象
> has(key)  判断是否包含键名key的对象，没有则返回undefined
> delete(key) 删除键名key的对象

### 常见异步笔试题，写出代码执行结果

```
async foo() {
  console.log('foo start');
  await bar();
  console.log('foo end');
}
async bar() {
  console.log('bar run');
}
console.log('script start');
setTimeout(() => {
  console.log('setTimeout');
}, 0)
foo();
new Promise((resolve, reject) => {
  resolve('promise1');
  console.log('promise2')
}).then(res => console.log(res))
console.log('script end')

// script start
// foo start
// bar run
// promise2
// script end
// foo end
// promise1
// setTimeout
```

这道题主要考察的是事件循环中函数执行顺序，其中包括async、await、setTimeout、promise。下面说说涉及的知识点：
1. 任务队列
> JS分为同步任务和异步任务
> 同步任务都在主线程上执行，形成一个执行栈
> 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
> 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行

根据规范，事件循环是通过任务队列的机制来进行协调的。一个Event Loop中可以有一个或多个任务队列（task queue），一个任务队列便是一系列有序任务（task）的集合；每个任务都有一个任务源（task source），源自统一任务源的task必须放在统一任务队列中。setTimeout/Promise等API便是任务源，进入任务队列的是他们指定的具体任务。
![Event Loop](../../../../image/event-loop.png)

2. 宏任务
(macro)task，可以理解为每次执行栈执行的代码就是一个宏任务
浏览器为了能够使得JS内部(macro)task和DOM任务能够有序执行，会在一个(macro)task执行结束后，在下一个(macro)task执行开始前，对页面进行重新渲染，流程如下：

```
(macro)task --> 渲染 --> (macro)task --> 渲染 --> (macro)task
```
主要包含：script（整体代码）、setTimeout、setInterval、possMessage、MessageChannel、I/O、UI交互事件
3. 微任务
(micro)task，可以理解是在当前task执行结束后立即执行的任务，也就是说，当前任务之后，下一个任务之前，在渲染之前执行的。
主要包含：Promise.then()

4. 运行机制
> 执行一个宏任务（执行栈中没有就从事件队列中取）
> 执行过程中，如果遇到微任务，便将微任务添加到微任务的任务队列中
> 宏任务执行完毕，立即执行微任务队列中的微任务（依次执行）
> 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
> 渲染完毕，JS线程继续接管，开始下一个宏任务。

![Event Loop Run](../../../../image/event-loop-run.png)

5. Promise和async中立即执行
Promise中的代码是立即执行的，异步体现在then和catch上。
async中，await之前是立即执行的，那await做了什么呢？
6. await做了什么
await是让出线程的标志。await后面的表达式先执行一遍，将await后面的代码加入到(micro)task中，然后就跳出了整个async函数来执行后面的代码。
由于async await本身就是promise+generator的语法糖。所以await后面的代码是(micro)task。
```
async foo() {
  console.log('foo start');
  await bar();
  console.log('foo end');
}
```
等价于
```
async foo() {
  console.log('foo start');
  Promise.resolve(bar()).then(res => console.log('foo end'))
}
```

### 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组
```
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b)
```

### JS异步解决方案的发展历程，及优缺点
1. 回调函数（callback）
```
setTimeout(() => {
  // callback 函数体
}, 1000)
```
缺点：形成回调地狱，不能使用try、catch捕捉错误，不能return
优点：解决了同步问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）
回调地狱形成的原因：
> 缺乏顺序行：调试困难，与大脑思维方式不符
> 嵌套函数存在耦合，牵一发动全身
2. Promise
Promise就是为了解决callback的问题而产生的
Promise实现了链式调用，每次then返回的都是一个全新的Promise对象，如果我们在then中return,return的结果回被Promise.resolve()包装
优点：解决了回调地狱的问题
缺点：无法取消Promise，错误需要通过回调函数来捕捉
3. Generator
特点：可以控制函数的执行，可以配合co数据库使用
```
function *fetch() {
  yield ajax('XXX1', () => {});
  yield ajax('XXX2', () => {});
  yield ajax('XXX3', () => {});
}
const fn = fetch();
let result1 = fn.next();
let result2 = fn.next();
let result3 = fn.next();
```
4. Async/await
async/await是异步的终极解决方案
优点：代码清晰，不用像promise写一堆then，解决了对调地狱的问题
缺点：await将异步代码改造同步代码，如果多个异步操作没有依赖性而是用await会导致性能上的降低。此种情况完全可以用Promise.all();
```
async function fetch() {
  await ajax('xxx1', () => {})
  await ajax('xxx2', () => {})
  await ajax('xxx3', () => {})
}
```
5. 如何实现一个new
```
function _new(fn, ...arg) {
  const obj = Object.create(fn.prototype);
  const ret = fn.apply(obj, arg);
  return ret instanceof Object ? ret : obj;
}

let Dog = function(name) {
  this.name = name;
}
Dog.prototype.sayHi = function() {
  console.log('旺旺')
}
let obb = _new(Dog, '二哈');
obb.name // '二哈'
obb.sayHi() // '旺旺'
```

### 简单讲下HTTP2的多路复用
简单说，就是同一个TCP连接，同一时刻可以传输多个http请求
> 之前是同一个连接只能使用一次，如果开启keep-alive，虽然可以使用多次，但同一时刻只能有一个http请求
详细点：
在HTTP/1中，每次请求都会创建一个TCP连接，也就是我们常说的3次握手4次挥手。这个过程在一次请求中占用了相当长的时间，即使开启了keep-alive，解决了多次连接的问题，但依然有两个效率上的问题：
> 第一个，串行文件传输，请求a文件时，b文件只能等着。等待a连接到服务器，服务器处理文件，服务器返回文件，这三个步骤。队头阻塞问题。
> 第二个，连接数过多，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个限制。假设Apache设置了最大并发数为300，那么服务器能承载的最高并发为6-8个，后面的请求就需要等待前面的某个请求处理完。
HTTP/2的多路复用就是为了解决这两个性能问题。
在HTTP/2中，有两个重要的概念，分别是帧（frame）和流（stream）
帧代表最小的单位，每个帧会标识出属于哪个流，流也就是多个帧组成的数据流。
多路复用就是一个TCP连接中可以有多个数据流。
HTTP/2采用二进制格式传输，HTTP/1采用的是文本格式传输，二进制解析更高效。
> 同域名下所有通信都在单个连接上完成，消除了多个TCP连接带来的延迟和内存消耗
> 单连接上可以并行多个交错的请求和响应，之间互不干扰

### ES5/ES6的继承除了写法以外，还有什么区别？
// 自己测试的没有什么区别。。。莫非只是对ES5继承的一种封装
```
class Super {}
class Sub extends Super{
  constructor(...args) {
    super(...args); // 等价于 Super.constructor.call(this, ...args)
  }
}
const sub = new Sub();
sub.__proto__ === Super;
```
子类可以通过__proto__直接寻址到父类
```
function Super () {}
function Sub () {}
Sub.prototype = new Super();
Sub.prototype.constructor = Sub;
var sub = new Sub();
sub.__proto__ === Function.prototype;
```
而通过ES5的方式，sub.__proto__ === Function.prototype

### 介绍下模块安装机制，为什么输入npm install就可以自动安装对应的模块？
安装机制：
1. 发出```npm install```指令
2. 查询node_modules目录之中是否已存在指定的模块
> 若存在不在安装
> 若不存在
>> npm向registry查询模块压缩包的网址
>> 下载压缩包，存在根目录下.npm目录里
>> 解压压缩包到当前的项目node_modules目录里

### 介绍下重绘和回流（Repaint & Reflow），以及如何优化
1. 浏览器渲染机制
> 浏览器采用流式布局模型（Flow Based Layout）
> 浏览器会把html解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就成了渲染树（Render Tree）
> 有了Render Tree，我们就知道所有节点的样式啦，然后计算他们在页面的大小和位置，最后把节点绘制到页面上。
> 浏览器对Render Tree的计算通常只需要遍历一遍即可完成，但table及其内部元素除外，他们可能需要计算多次，通常要花3倍于同等元素的时间，这也是为什么要避免使用table的原因之一。
2. 重绘
由于节点的样式发生改变而不影响布局，称为重绘。
例如：```color、background-color、visibility```
重绘的代价昂贵，浏览器必须验证DOM上其他节点的可见性。
3. 回流
节点的几何属性需要改变且影响了布局，称为回流。
回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（乃至整个页面）的布局更新。一个节点的回流，可能导致其子节点以及DOM中紧随其后的节点、祖先节点元素的回流。
大部分回流导致页面重新渲染。
4. 重绘、回流的关系
回流必会发生重绘，重绘不一定发生回流。
5. 浏览器优化
现代浏览器通过队列机制来批量更新布局，浏览器会把修改操作放到队列里，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你回去布局信息的时候，队列中可能有影响布局的属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘，确保返回正确的值。
主要包括以下信息或方法：
```
1. offsetTop、offsetLeft、offsetWidth、offsetHeight;
2. scrollTop、scrollLeft、scrollWidth、scrollHeight;
3. clientTop、clientLeft、clientWidth、clientHeight;
4. width、height
5. getComputedStyle()
6. getBoundingClientRect()
```
使用上述属性，浏览器都会强制刷新队列
6. 减少回流与重绘
CSS
> 使用visibility替换display: none，因为前者只会引起重绘，后者会引起回流
> 避免使用table布局，可能很小的一个改动，就会造成整个table的重新布局
> 尽可能在DOM树的最末端改变class，以减少回流的影响
> 避免设置多层内联样式，CSS选择符从右往左匹配查找，避免节点层级过多。
> 将动画效果应用到position为absolute、fixed元素上。避免影响其他元素的布局。同时控制动画速度，可以使用```requestAnimationFrame```
> 使用GPU硬件加速
JS
> 避免频发操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改。
> 避免频发操作DOM，创建一个```documentFragement```，在它上面应用所有DOM操作，最后再把它添加到文档中。
> 避免频繁读取引起回流/重绘的属性，如果需要多次使用，就用一个变量缓存起来。

### 介绍下观察者模式和订阅-发布模式的区别，各自使用场景？
可以简单理解为：
观察者模式：没有中间商赚差价
订阅-发布模式：有中间商赚差价
1. 联系
发布-订阅模式是观察模式的一种变体，发布-订阅模式只是将一部分功能抽象成一个独立的ChangeManager。
2. 意图
都是某个对象（subject,publisher）改变，使依赖于它的多个对象（observers,subscribers）得到通知。
3. 区别与适用场景
总的来说，发布-订阅模式适合更复杂的场景。
在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？
在「多对一」或「多对多」的场景下，一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是所有发布者都更新完毕后，再通知订阅者？
这些逻辑都可以放在ChangeManager里。

### 介绍模块化发展历程
模块化主要用来抽离公共代码，隔离作用域，避免变量冲突。
IIFE： 使用自执行函数编写模块化
> 特点：在一个单独的函数作用域中执行代码，避免变量冲突
AMD：使用requireJS来编写模块
> 特点：依赖必须提前声明好
CMD：使用seaJS来编写模块
> 特点：支持动态引入依赖文件
CommonJS：nodejs中自带的模块化。
UMD：兼容AMD、CommonJS等模块化语法
ES Modules：ES6引入的模块化，支持import引入另一个js文件
接下来重点说一下CommonJS和ES Modules
CommonJS:
> 特点：require、exports、module.exports
CommonJS一般用在服务端或node用来同步加载模块，处理模块依赖发生在代码运行阶段，不适合浏览器端做异步加载。
exports实际上是一个对module.exports的引用：
```
exports.add = 'xxx';
等同于
module.exports.add = 'xxx'
```
不能直接给exports赋值，否则会断开与module.exports的连接。

ES6 Module
> 特点：import、export
ES6模块化不是对象，import会在JavaScript引擎静态分析，在编译时就引入代码，而并非在代码运行时引入代码。因此也不适合异步加载。
在Html中如果需要引入模块，需要这样写：
```
<script type="module" src="./module.js"></script>
```
优势：
> 死代码检查和排除，我们可以用静态分析工具检测出哪些模块没有被调用到。去掉这些不会使用到的模块，减下包的体积。
> 编译器优化，在CommonJS等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象。而ES6 Module直接导入变量，减少了引用层级，代码效率更高
CommonJS 与 ES6 Module的区别：
> CommonJS在引入时是加载整个模块，是生成一个对象，然后再从这个生成的对象上读取方法和属性。
> ES Module不是对象，而是通过export暴露的代码块，在import时使用静态命令的方法引入指定的输出代码块，并在import语句出执行这个要输出的代码，而不是直接加载整个模块
> CommonJS引用后是一个值的拷贝
> ES Module引用后是一个值得动态映射
[ES6 export/export default/import](https://es6.ruanyifeng.com/#docs/module#export-%E5%91%BD%E4%BB%A4)

### js中的排序算法
冒泡排序
时间复杂度：O(n^2)
```
function bobbleSort1(arr) {
  let len = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] < arr[j + 1]) {
        let temp;
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
  return arr;
}
```
快速排序
时间复杂度：O(nlogn)
```
function quickSort(arr) {
  if (arr.length < 2) return arr;
  let middleIndex = Math.floor(arr.length / 2);
  let middleValue = arr.splice(middleIndex, 1)[0];
  let left = [], right = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < middleValue) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(middleValue, quickSort(right))
}
```

### 请把两个数组[A1,A2,B1,B2,C1,C2,D1,D2]和[A,B,C,D]，合并成[A1,A2,A,B1,B2,B,C1,C2,C,D1,D2,D]
```
function sort(arr1, arr2) {
  let arr = [...arr1];
  for (let i = 0; i < arr2.length; i++) {
    let temp = arr2[i] + '2';
    let index = arr.indexOf(temp);
    if (index > -1) {
      arr.splice(++index,0,arr2[i])
    }
  }
  return arr;
}
```
```
function sortDemo(arr1, arr2) {
  let arr = [...arr1];
  for(let i = 0; i < arr2.length; i++) {
    arr.push(arr2[i]+'3')
  }
  arr = arr.sort().map(item => {
    if (item.includes('3')) {
      return item.split('')[0]
    }
    return item;
  })
  return arr;
}
```

### 改造下面代码，使之输出0-9，写出你能想到的所有解法。
利用let特性，每次循环过程中，let会在当前的块级作用域中创建文法环境，该环境中包含当前for循环的变量i；
```
for(let i = 0; i < 10; i++) {
  setTimeout(()=> {
    console.log(i)
  }, 1000)
}
```
利用setTimeout的第三个参数，会作为回调参数的第一个参数传入；
```
for(var i = 0; i < 10; i++) {
  setTimeout((i) => {
    console.log(i)
  }, 1000, i)
}
```
利用bind部分执行的特性；
```
for(var i = 0; i < 10; i++) {
  setTimeout((i => {
    console.log(i)
  }).bind(Object.create(null), i), 1000)
}
```
利用函数自执行的方式，把当前for循环中的传进去，构成块级作用域。
```
for(var i = 0; i < 10; i++) {
  (function(i){
    setTimeout(() => {
      console.log(i);
    }, 1000)
  })(i)
}
```

### 聊聊Redux和Vuex的设计思想
共同点：
首先两者都是处理全局状态的工具库，大致实现思想都是：全局state保存状态--->dispatch(action)--->reducer(vuex中的mutation)--->生成newState;整个状态为同步操作。
不同点：
最大的区别在于处理异步的不同，vuex中多了异步commit操作，在action之后commit(mutation)之前处理异步，而redux里面通过中间件处理。
[知乎Vuex和Redux](https://zhuanlan.zhihu.com/p/53599723)

### 执行下面代码，输出结果，解释原因
```
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})()
// 输出的结果：
ƒ b() {
  b = 20;
  console.log(b)
}
```
原因：
作用域可以理解为上下文中声明的变量和作用的范围。包括块级作用域和函数作用域、全局作用域。
特性：声明提前，一个声明在函数体内都是可见的，函数声明优先于变量声明。在非匿名自执行函数中，函数变量为制度状态，无法修改。

### 使用迭代的方式实现flatten函数
```
function flatten(arr) {
  while(arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
}
```
```
function flatten(arr) {
  let arrs = [...arr];
  let newArr = [];
  while(arrs.length) {
    let item = arrs.shift();
    if (Array.isArray(item)) {
      arrs.unshift(...item);
    } else {
      newArr.push(item);
    }
  }
  return newArr;
}
```
```
function flatten(arr) {
  let arrs = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      arrs.push(...flatten(item));
    } else {
      arrs.push(item);
    }
  })
  return arrs;
}
```

### 下面程序怎么打印出1来
```
var a = ?;
if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```
考察的是==隐式类型转换，我们重写toString方法就可以了，转换时会调用对象本身的toString或valueOf方法
```
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}
if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```
```
var a = {
  i: 1,
  valueOf() {
    return a.i++;
  }
}
if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```
```
var a = [1, 2, 3];
a.toString = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```

### 介绍下BFC及其应用
BFC：块级格式上下文，是页面盒模型布局中的一种css渲染方式，相当于一个独立的容器，里面的元素和外面的元素互不影响。
创建BFC的方式：
> html根元素
> float浮动
> 绝对定位
> overflow不为visible
> display为表格布局或弹性布局
作用：
清除浮动，
防止同一BFC容器中相邻元素间外边距重叠

### 在Vue中，子组件为何不能修改父组件传进来的prop，如果修改了，Vue是如何监控到属性的修改并给出警告的？
原因：单项数据流，易于检测数据的流动，出现错误可以更快速的定位到错误发生的位置。
如果修改了，Vue是如何健康到属性的修改并给出警告的？
```
if (process.env.NODE_ENV !== 'production') {
  var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
}
```
在initProps的时候，在defineReative时通过判断当前是否在开发环境，如果是开发环境，会在触发set时判断是否此key处于updatingChildren中被修改，如果不是，则说明修改来自子组件，触发warning提示。

### 执行下面代码，输出的结果是？
```
var a = 10;
(function() {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})()
// undefined
// 10
// 20
```

### 实现一个sleep函数，比如sleep(1000)意味着要等待1000毫秒，可从Promise、Generator、Async/await
```
function sleep(time) {
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('执行啦');
    }, time)
  }).then(res => {
    console.log(res)
  })
}
```
```
function* sleep(time) {
  yield new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('执行完了')
    }, time)
  })
}
sleep(1000).next().value.then(res => console.log(res))
```
```

async function sleep(time) {
  const result = await new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('执行完了');
    }, time)
  })
  console.log(result);
}
```

### 介绍HTTPS握手的过程
1. 客户端使用HTTPS的url访问web服务器，要求与服务器建立ssl连接
2. web服务器收到请求后，会将网站的证书（包含公钥）传送一份给客户端
3. 客户端收到网站证书后，检查证书的颁发机构以及过期时间，如果没有问题就随机产生一个秘钥
4. 客服端利用公钥将会话秘钥加密，并传送给服务端，服务端利用自己的私钥解密出会话秘钥
5. 之后客户端与服务端使用会话秘钥加密传输

### HTTPS握手过程中，客户端如何验证证书的合法性？
（1）首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内
（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发
（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布
版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密
（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充

### 输出以下代码的结果，并解释原因
```
var a = {
  '2': 3,
  '3': 4,
  length: 2,
  splice: Array.prototype.splice,
  push: Array.prototype.push
}
a.push(1);
a.push(2);
console.log(a);
// Object(4)
// 2: 1
// 3: 2
// length: 4
// push: ƒ push()
// splice: ƒ splice()
// __proto__: Object
```
涉及知识点：

类数组（ArrayLike）：
一组数据，由数组来存，但是如果要对这组数据进行扩展，会影响到数组原型，ArrayLike的出现则提供了一个中间数据桥梁，ArrayLike有数组的特性， 但是对ArrayLike的扩展并不会影响到原生的数组。

push方法：
push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。
唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。

对象转数组的方式：
Array.from()、splice()、concat()等

### Vue中双向数据绑定和Vuex是否冲突
在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案：
1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值
2、使用带有setter的双向绑定计算属性。见以下例子（来自官方文档）：
```
<input v-model="message">
computed: { message: { get () { return this.$store.state.obj.message }, set (value) { this.$store.commit('updateMessage', value) } } }
```

### cal和apply有什么区别，哪个性能更好些？
1. Function.prototype.apply和Function.prototype.call 的作用是一样的，区别在于传入参数的不同；
2. 第一个参数都是，指定函数体内this的指向；
3. 第二个参数开始不同，apply是传入带下标的集合，数组或者类数组，apply把它传给函数作为参数，call从第二个开始传入的参数是不固定的，都会传给函数作为参数。
4. call比apply的性能要好，平常可以多用call, call传入参数的格式正是内部所需要的格式

### 为什么通常在发送数据埋点请求的时候通常使用的是1*1像素的透明的gif图片？
作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的1x1 像素的透明 gif 图片；
why?
1. 没有跨域问题，一般这种上报数据，代码要写通用的；（排除ajax）
2. 不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报）
3. 在所有图片中，体积最小；（比较PNG/JPG）
4. 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
5. 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
6. 跨域友好
7. 执行过程无阻塞
8. 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
9. GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）

### 实现(5).add(3).minus(2)
```
Number.prototype.add = function(n) {
  return this.valueOf() + n;
}
Number.prototype.minus = function(n) {
  return this.valueOf() - n;
}
(5).add(3).minus(2)
```

### Vue的响应式原理中Object.defineProperty有什么缺陷？为什么在3.0中采用了Proxy，抛弃了Object.defineProperty?
1. Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
2. Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。
3. Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

### 怎么让一个div垂直水平居中。
```
<div class="parent">
  <div class="child" style="width: 50px;height: 50px;background: yellow;"></div>
</div>
```
```
div.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```
```
div.parent {
  display: flex;
}
div.child {
  margin: auto;
}
```
```
div.parent {
  position: relative;
  height: 100px;
}
div.child {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}
```
```
div.parent {
  position: relative;
  height: 100px;
}
div.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-25px, -25px);
}
```
```
div.parent {
  position: relative;
  height: 100px;
}
div.child {
  position: absolute;
  top: 50%;
  left: 50%;
  margin-top: -25px;
  margin-left: -25px;
}
```
```
div.parent {
  display: grid;
}
div.child {
  justify-self: center;
  align-self: center;
}
```

### 执行下面代码，给出输出结果，并解释为什么？
```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b.x);
// undefined
// {n: 2}
```
首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。
后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。
```
b.x = a = {n: 2}
```

### 冒泡排序如何实现？时间复杂度是多少？还可以如何改进？
时间复杂度：n^2
```
function buddleSort(arr) {
  console.time('yes')
  if (!Array.isArray(arr)) return;
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
  console.timeEnd('yes')
  return arr;
}
```
改进后
```
function buddleSort(arr) {
  console.time('abc1');
  if (!Array.isArray(arr)) return;
  let i = arr.length - 1;
  while(i > 0) {
    let pos = 0;
    for (let j = 0; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        pos = j;
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp; 
      }
    }
    i = pos;
  }
  console.timeEnd('abc1');
  return arr;
}
```

### 某公司1到12月份的销售额存在一个对象里
```
let data = {1: 222, 2: 123, 5: 888};
const arr = Array.from({length: 12}).map((_, index) => data[index + 1] || null);
console.log(arr);
```

### 要求设计LazyMan类，实现以下功能。
```
class LazyManClass {
  constructor(name) {
    this.name = name;
    this.taskList = [];
    console.log(`Hi I am ${name}`);
    setTimeout(() => {
      this.next();
    }, 0)
  }
  sleep(time) {
    let that = this;
    let fn = (function(time) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${time}秒...`);
          that.next();
        }, time * 1000)
      }
    })(time)
    this.taskList.push(fn);
    return this;
  }
  eat(something) {
    let that = this;
    let fn = (function(something) {
      return function() {
        console.log(`I am eating ${something}`)
        that.next();
      }
    })(something)
    this.taskList.push(fn);
    return this;
  }
  sleepFirst(time) {
    let that = this;
    let fn = (function(time) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${time}秒...`);
          that.next();
        }, time * 1000)
      }
    })(time)
    this.taskList.unshift(fn);
    return this;
  }
  next() {
    if (this.taskList.length === 0 ) return;
    let fn = this.taskList.shift();
    fn && fn();
  }
}
function LazyMan(name) {
  return new LazyManClass(name);
}
```

### 分析比较opacity:0、visibility: hidden、display: none优劣和适用场景？
```
display: none;
```
1. DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间；
2. 事件监听：无法进行 DOM 事件监听；
3. 性能：动态改变此属性时会引起重排，性能较差；
4. 继承：不会被子元素继承，毕竟子类也不会被渲染；
5. transition：transition 不支持 display。
```
visibility: hidden;
```
1. DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间；
2. 事件监听：无法进行 DOM 事件监听；
3. 性 能：动态改变此属性时会引起重绘，性能较高；
4. 继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏；
5. transition：transition 不支持 display。
```
opacity: 0;
```
1. DOM 结构：透明度为 100%，元素隐藏，占据空间；
2. 事件监听：可以进行 DOM 事件监听；
3. 性 能：提升为合成层，不会触发重绘，性能较高；
4. 继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏；
5. transition：transition 不支持 opacity。

### 箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？
箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
2. 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
3. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
4. 不可以使用 new 命令，因为：
没有自己的 this，无法调用 call，apply。
没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__
new操作符大致过程是这样的：
```
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === 'object' || typeof result2 === 'function') &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}
```

### 给定两个数组，写一个方法计算他们的交集。
```
let arr1 = [1,4,5,6,4,6], arr2 = [2,4,6,8,4,6];
function fn(arr1, arr2) {
  return arr1.filter((item, index) => {
    if (arr2.includes(item)) {
      return item;
      arr2.splice(index, 1);
    }
  })
}
fn(arr1, arr2)
```
哈希表，时间复杂度O(m+n),m:arr1的长度，n:arr2的长度
```
function intersect(arr1, arr2) {
  const map = {};
  const res = [];
  for (let n of arr1) {
    if (map[n]) {
      map[n]++;
    } else {
      map[n] = 1;
    }
  }
  for (let n of arr2) {
    if (map[n] > 0) {
      res.push(n);
      map[n]--;
    }
  }
  return res;
}
```

### 已知如下代码，如何修改才能使图片宽度为300px？注意下面代码不可修改。
```<img src="1.jpg" style="width:480px!important;" >```
```
img {
  max-width: 300px;
}
```
```
img {
  box-sizing: border-box;
  padding-right: 180px;
}
```
```
img {
  transform: scale(0.625, 0.625);
}
```
```
img {
  animation: imgWH 0s forwards;
}
@keyframes imgWH {
  from {
    width: 300px;
  } 
  to {
    width: 300px;
  }
}
利用CSS动画的样式优先级高于!important的特性
```

### 介绍下如何实现token加密
jwt举例
1. 需要一个secret（随机数）
2. 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端
前端每次request在header中带上token
3. 后端用同样的算法解密
4. 这边也是这么做的，后端根据token来查权限和是否登录以及失效等

### 如何设计实现无缝轮播
无限轮播基本插件都可以做到,不过要使用原生代码实现无缝滚动的话我可以提点思路,
因为轮播图基本都在ul盒子里面的li元素,
首先获取第一个li元素和最后一个li元素,
克隆第一个li元素,和最后一个li元素,
分别插入到lastli的后面和firstli的前面,
然后监听滚动事件,如果滑动距离超过x或-x,让其实现跳转下一张图或者跳转上一张,(此处最好设置滑动距离),
然后在滑动最后一张实现最后一张和克隆第一张的无缝转换,当到克隆的第一张的时候停下的时候,,让其切入真的第一张,则实现无线滑动,向前滑动同理

### 模拟实现一个Promise.finally
```
Promise.prototype.finally = function(callback) {
  let p = this.constructor;
  return p.then(
    value => Promise.resolve(callback()).then(() => value),
    reason => Promise.resolve(callback()).then(() => reason)
  )
}
```

### a.b.c.d和a['b']['c']['d']，哪个性能更高？
应该是 ```a.b.c.d``` 比 ```a['b']['c']['d']``` 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。
这个题从AST角度看就很简单了，```a['b']['c']['d']```和```a.b.c.d```，转换成AST前者的的树是含计算的，后者只是string literal，天然前者会消耗更多的计算成本，时间也更长

### ES6代码转换为ES5代码实现思路？
题目说的是 ES6，所以不考虑 .jsx、.ts 这类 js 拓展语言。
ES6 转 ES5 目前行业标配是用 Babel，转换的大致流程如下：

解析：解析代码字符串，生成 AST；
转换：按一定的规则转换、修改 AST；
生成：将修改后的 AST 转换成普通代码。
如果不用工具，纯人工的话，就是使用或自己写各种 polyfill 了。
补充说明：
> .vue文件通过webpack的vue-loader分析出script style template 再走上面的ES6转ES5流程
> jsx通过babel插件转js语法再走ES6转ES5
> ts通过tsc结合tsconfig.json直接转ES5

### 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]
```
function fn() {
  let arr = Array.from({length: 10}).map(item => item = Math.random().toFixed(2)*100)
  console.log(arr)
  let arr1 = [...new Set(arr)].sort((a, b) => a - b);
  console.log(arr1)
  let arr2 = []
  arr1.forEach(item => {
    let key = parseInt(item / 10);
    if (!arr2[key]) {
      arr2[key] = [];
    } 
    arr2[key].push(item)
  })
  console.log(arr2)
}
```

### 实现0.5像素边框/如何解决移动端Retina屏1像素问题
1. 伪元素 + transform scaleY(0.5)
2. border-image
3. background-image
4. box-shadow

### 
```
function processString(str) {
  let arr = str.split('').map(item => {
    if (item === item.toLowerCase()) {
      return item.toUpperCase();
    } else {
      return item.toLowerCase()
    }
  });
  return arr.join('');
}
```
```
'AbcDefGh'.replace(/[a-zA-Z]/g,function(a){ return /[a-z]/.test(a)?a.toUpperCase():a.toLowerCase(); });
```

### 介绍webpack热更新原理，是如何做到在不刷新浏览器的前提下更新页面的？
1. 当修改了一个或多个文件；
2. 文件系统接收更改并通知webpack；
3. webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；
4. HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；
5. HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。

关于webpack的热更新原理，面试官比较想听到的是工作流程和关键点，非“流水账”式的源码分析。我认为可以这样的介绍：

首先，介绍webpack-dev-server:
webpack-dev-server 主要包含了三个部分：
1. webpack: 负责编译代码
2. webpack-dev-middleware: 主要负责构建内存文件系统，把webpack的 OutputFileSystem 替换成 InMemoryFileSystem。同时作为Express的中间件拦截请求，从内存文件系统中把结果拿出来。
3. express：负责搭建请求路由服务。

其次，介绍工作流程:
1. 启动dev-server，webpack开始构建，在编译期间会向 entry 文件注入热更新代码；
2. Client 首次打开后，Server 和 Client 基于Socket建立通讯渠道；
3. 修改文件，Server 端监听文件发送变动，webpack开始编译，直到编译完成会触发"Done"事件；
4. Server通过socket 发送消息告知 Client；
5. Client根据Server的消息（hash值和state状态），通过ajax请求获取 Server 的manifest描述文件；
6. Client对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块；
7. Client获取到新的JS模块后，会更新 modules tree并替换掉现有的模块；
8. 最后调用 module.hot.accept() 完成热更新；

### 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。
```
function fn(s, t) {
  if (s.length < t.length) return -1;
  let arr = s.split(t);
  return arr.length > 1 ? arr[0].length : -1;
}
```
```
function fn(s, t) {
  if (s.length < t.length) return -1;
  for(let i = 0,len = s.length - t.length; i < len; i++) {
    if (s.substr(i, t.length) === t) {
      return i;
    }
  }
  return -1;
}
```

### 
```
function fn() {
  let arrs = new Array(10000000);

  console.time('for');
  for (let i = 0; i < arrs.length; i++) {

  };
  console.timeEnd('for');

  console.time('forEach');
    
  arrs.forEach((arr) => {
  
  });
  console.timeEnd('forEach');
}
```
在10万这个级别下， forEach 的性能是 for的十倍
```
for: 2.263ms
forEach: 0.254ms
```
在100万这个量级下， forEach 的性能是和for的一致
```
for: 2.844ms
forEach: 2.652ms
```
在1000万级以上的量级上 ， forEach 的性能远远低于for的性能
```
for: 8.422ms
forEach: 30.328m
```

for循环是常见的循环语句forEach和map是在ES5出的，但是在性能上后者不如前者，在次数少的情况下forEach会比for要快，但是到达了十万次时forEach明显就跟不上了。在大数据量的情况下for循环的兼容性和多环境运行表现比较优秀，forEach的优点是在数据量小时占优势，语义话更简洁。循环时没有返回值。map和forEach差不多但是map循环有返回值

### 介绍下BFC、IFC、GFC和FFC
1. BFC（Block formatting contexts）：块级格式上下文
页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发BFC的元素有float、position、overflow、display：table-cell/ inline-block/table-caption ；BFC有什么作用呢？比如说实现多栏布局’

2. IFC（Inline formatting contexts）：内联格式上下文
IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同
IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。
那么IFC一般有什么用呢？
水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。
垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。

3. GFC（GrideLayout formatting contexts）：网格布局格式化上下文
当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。

4. FFC（Flex formatting contexts）:自适应格式上下文
display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。

### 使用JavaScript Proxy实现简单的双向数据绑定。
```
<body>
  hello world
  <input type="text" id="model">
  <p id="word"></p>
</body>
<script>
  const inputEl = document.querySelector('#model');
  const pEl = document.querySelector('#word');
  var obj = {};
  const newObj = new Proxy(obj, {
    get(target, key, receiver) {
      return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
      if (key === 'text') {
        inputEl.value = value;
        pEl.innerHtml = value;
      }
      return Reflect.set(target, key, value, receiver)
    }
  })
  inputEl.addEventListener('keyup', e => {
    newObj.text = e.target.value;
  })
</script>
```

### 数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少
```
function fn() {
  let arr = new Array(100000);
  console.time('first');
  const item = arr[0];
  console.timeEnd('first');
  console.time('end');
  const item1 = arr[99999];
  console.timeEnd('end');
}
// first: 0.0029296875ms
// end: 0.001953125ms
```

### 输出下面代码运行的结果
这题考察的是对象的键名的转换：
1. 对象的键名只能是字符串和 Symbol 类型。
2. 其他类型的键名会被转换成字符串类型。
3. 对象转字符串默认会调用 toString 方法。
```
// example 1
var a={}, b='123', c=123;
a[b]='b';

// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。
a[c]='c';  

// 输出 c
console.log(a[b]);
```
```
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  

// b 是 Symbol 类型，不需要转换。
a[b]='b';

// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。
a[c]='c';

// 输出 b
console.log(a[b]);
```
```
// example 3
var a={}, b={key:'123'}, c={key:'456'};  

// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
a[b]='b';

// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。
a[c]='c';  

// 输出 c
console.log(a[b]);
```

### 旋转数组算法题
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4] 

```
function fn(arr, k) {
  for(let i = 0; i < k; i++) {
    arr.unshift(arr.pop())
  }
  return arr;
}
```
```
function fn(arr, k) {
  let num = arr.length % k;
}
```

### Vue 的父组件和子组件生命周期钩子执行顺序是什么
1. 加载渲染过程
```
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
```
2. 子组件更新过程
```
父beforeUpdate->子beforeUpdate->子updated->父updated
```
3. 父组件更新过程
```
父beforeUpdate->父updated
```
4. 销毁过程
```
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

### 介绍下 Promise.all 使用、原理实现及错误处理
```
Promise.all = function(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('argument must be an array'))
    }
    var countNum = 0;
    var promiseNum = promises.length;
    var resolvedValue = new Array(promiseNum);
    for(var i = 0; i < promiseNum; i++) {
      (function(i) {
        Promise.resolve(promises[i]).then(res => {
          countNum++;
          resolvedValue[i] = res;
          if (countNum === promiseNum) {
            return resolve(resolvedValue)
          }
        }, err => {
          return reject(err)
        })
      })(i)
    }
  })
}
```

### 打印出 1 - 10000 之间的所有对称数 例如 121、1331 等
```
function fn() {
  let result = [];
  for(let i = 1; i < 10000; i++) {
    let item = i + '';
    if (item.length > 1 && item === item.split('').reverse().join('')) {
      result.push(item * 1)
    }
  }
  console.log(result)
}
```
```
function fn() {
  return [...Array(10000).keys()].filter(item => {
    return item.toString().length > 1 && item === item.toString().split('').reverse().join('')*1
  })
}
```

### 算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
```
function fn(arr) {
  if (!Array.isArray(arr)) return;
  let zeroArr = [];
  let list = arr.filter(item => {
    if (item === 0) {
      zeroArr.push(0);
    }
    return item !== 0
  })
  return [...list, ...zeroArr]
}
```
```
function fn(arr) {
  if (!Array.isArray(arr)) return;
  let len = arr.length;
  let j = 0, i = 0;
  for(i = 0; i < len - j; i++) {
    if (arr[i] === 0) {
      arr.push(0);
      arr.splice(i, 1);
      i--;
      j++;
    }
  }
  return arr;
}
```

### var、let 和 const 区别的实现原理是什么
1. var声明的变量会挂载在window上，而let和const声明的变量不会
```
var a = 100;
let b = 100;
const c = 100;
console.log(a, window.a); // 100 100
console.log(b, window.b); // 100 undefined
console.log(c, window.c); // 100 undefined
```
2. var声明变量存在变量提升，let和const不存在变量提升
```
console.log(a); // undefined
var a = 100;
console.log(b); // Uncaught ReferenceError: b is not defined
let b = 100;
console.log(c); // Uncaught ReferenceError: Cannot access 'c' before initialization
const c = 100;
```
3. let和const声明形成块作用域，而var不存在此作用域
```
{
  var a = 100;
  let b = 100;
  const c = 100;
}
console.log(a); // 100
console.log(b); // Uncaught ReferenceError: b is not defined
console.log(c); // Uncaught ReferenceError: c is not defined
```
4. 同一作用域下let和const不能声明同名变量，而var可以
```
var a = 100;
let b = 100;
const c = 100;
var a = 200;
let b = 200; // Uncaught SyntaxError: Identifier 'b' has already been declared
const c = 200; // Uncaught SyntaxError: Identifier 'c' has already been declared
```
5. let、const存在暂存死区
```
var a = 100;
{
  a = 200; // Uncaught ReferenceError: Cannot access 'a' before initialization
  let a = 300;
}
```
6. const
> 一旦声明必须赋值,不能使用null占位。
> 声明后不能再修改
> 如果声明的是复合类型数据，可以修改其属性

我们就从声明过程，内存分配，和变量提升这三点来看这三者之间的区别。

一.声明过程
var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来
function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行
const、class都是同let一样的道理
比如解析如下代码步骤：

{
// 没用的第一行
// 没用的第二行
console.log(a) // 如果此时访问a报错 a is not defined
let a = 1
}
步骤：

发现作用域有let a，先注册个a，仅仅注册
没用的第一行
没用的第二行
a is not defined，暂时性死区的表现
假设前面那行不报错，a初始化为undefined
a赋值为1
对比于var，let、const只是解耦了声明和初始化的过程，var是在任何语句执行前都已经完成了声明和初始化，let、const仅仅是在任何语句执行前只完成了声明。

二.内存分配
var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

三.变量提升
let const 和var三者其实会存在变量提升

let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。
var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined
function 的创建、初始化、赋值都被提升了

### 请实现一个 add 函数，满足以下功能。
```
add(1); 	// 1
add(1)(2);  	// 3
add(1)(2)(3)；  // 6
add(1)(2, 3);   // 6
add(1, 2)(3);   // 6
add(1, 2, 3);   // 6
```
```
function add() {
  let args = Array.from(arguments);
  let fn = function() {
    let fn_args = Array.from(arguments);
    return add.apply(null, args.concat(fn_args))
  }
  fn.toString = function() {
    return args.reduce((res, cur) => res + cur)
  }
  return fn;
}
```

### 算法题之「两数之和」
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例：
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
```
function fn(arr, target) {
  let len = arr.length;
  for(let i = 0; i < len; i++) {
    for(let j = 0; j < len; j++) {
      if (i !== j && arr[i] + arr[j] === target) {
        return [i, j]
      }
    }
  }
}
```

### 在输入框中如何判断输入的是一个正确的网址

### 实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度

### 设计并实现 Promise.race()
```
Promise._race = function (promises) {
  if (!Array.isArray(promises)) {
    return new TypeError('args is not Array');
  }
  return new Promise((resolve, reject) => {
    for(let i = 0; i < promises.length; i++) {
      Promise.resolve(promises[i]).then(resolve, reject)
    }
  })
}
```

### 实现模糊搜索结果的关键词高亮显示
我的大概思路是，用正则替换掉关键词。
```
let panter = new RegExp(关键词, 'g')
该行字符串.replace(panter, '<b style="color: #2D7BFF">' + 关键词 + '</b>')
```
ps:如果是vue项目，直接与v-html结合使用更爽哦~

### 介绍下 HTTPS 中间人攻击
https协议由 http + ssl 协议构成，具体的链接过程可参考SSL或TLS握手的概述
中间人攻击过程如下：
1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密hash值发给服务器。
5. 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密hash值，发给服务器。
7. 服务器用私钥解密获得假秘钥。
8. 服务器用加秘钥加密传输信息
防范方法：
服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性

### 已知数据格式，实现一个函数 fn 找出链条中所有的父级 id

### 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))
```
function fn(arr1, arr2) {
  let arr = arr1.concat(arr2);
  let mid = Math.floor(arr.length/2);
  arr = arr.sort((a, b) => a - b)
  if (arr.length % 2 === 0) {
    console.log(arr, mid, 'even')
    return (arr[mid - 1] + arr[mid]) / 2;
  } else {
    console.log(arr, mid, 'single')
    return arr[mid];
  }
}
```

### vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？
首先我们需要知道事件代理主要有什么作用？
1. 事件代理能够避免我们逐个的去给元素新增和删除事件
2. 事件代理比每一个元素都绑定一个事件性能要更好
从vue的角度上来看上面两点:
1. 在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了
2. 在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理

### 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况
定制需求如下：
1、循环引用
2、Symbol 类型拷贝
```
function deepCopy(obj, map = new WeekMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  // 循环引用
  if (map.has(obj)) return map.get(obj);
  let cobj = Array.isArray(obj) ? [] : {};
  map.set(obj, cobj);
  // 获取对象中所有属性名(包括Symbol)
  let keys = [...Object.keys(obj), ...Object.getOwnPropertySymbol(obj)]
  let len = keys.length;
  while(len--){
    cobj[keys[len]] = deepCopy(obj[keys[len]], map)
  }
  return cobj;
}
```

### 介绍下前端加密的常见场景和方法
首先，加密的目的，简而言之就是将明文转换为密文、甚至转换为其他的东西，用来隐藏明文内容本身，防止其他人直接获取到敏感明文信息、或者提高其他人获取到明文信息的难度。
通常我们提到加密会想到密码加密、HTTPS 等关键词，这里从场景和方法分别提一些我的个人见解。


场景-密码传输
前端密码传输过程中如果不加密，在日志中就可以拿到用户的明文密码，对用户安全不太负责。
这种加密其实相对比较简单，可以使用 PlanA-前端加密、后端解密后计算密码字符串的MD5/MD6存入数据库；也可以 PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行MD5/MD6，全程密码明文不出现在程序中。

PlanA
使用 Base64 / Unicode+1 等方式加密成非明文，后端解开之后再存它的 MD5/MD6 。

PlanB
直接使用 MD5/MD6 之类的方式取 Hash ，让后端存 Hash 的 Hash 。


场景-数据包加密
应该大家有遇到过：打开一个正经网站，网站底下蹦出个不正经广告——比如X通的流量浮层，X信的插入式广告……（我没有针对谁）
但是这几年，我们会发现这种广告逐渐变少了，其原因就是大家都开始采用 HTTPS 了。
被人插入这种广告的方法其实很好理解：你的网页数据包被抓取->在数据包到达你手机之前被篡改->你得到了带网页广告的数据包->渲染到你手机屏幕。
而 HTTPS 进行了包加密，就解决了这个问题。严格来说我认为从手段上来看，它不算是一种前端加密场景；但是从解决问题的角度来看，这确实是前端需要知道的事情。

Plan
全面采用 HTTPS


场景-展示成果加密
经常有人开发网页爬虫爬取大家辛辛苦苦一点一点发布的数据成果，有些会影响你的竞争力，有些会降低你的知名度，甚至有些出于恶意爬取你的公开数据后进行全量公开……比如有些食谱网站被爬掉所有食谱，站点被克隆；有些求职网站被爬掉所有职位，被拿去卖信息；甚至有些小说漫画网站赖以生存的内容也很容易被爬取。

Plan
将文本内容进行展示层加密，利用字体的引用特点，把拿给爬虫的数据变成“乱码”。
举个栗子：正常来讲，当我们拥有一串数字“12345”并将其放在网站页面上的时候，其实网站页面上显示的并不是简单的数字，而是数字对应的字体的“12345”。这时我们打乱一下字体中图形和字码的对应关系，比如我们搞成这样：

图形：1 2 3 4 5
字码：2 3 1 5 4

这时，如果你想让用户看到“12345”，你在页面中渲染的数字就应该是“23154”。这种手段也可以算作一种加密。
具体的实现方法可以看一下《Web 端反爬虫技术方案》。

### React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？

### 写出如下代码的打印结果
```
function changeObjProperty(o) {
  o.siteUrl = "http://www.baidu.com"
  o = new Object()
  o.siteUrl = "http://www.google.com"
} 
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
// http://www.baidu.com
```

### 编程算法题
```
用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。
```
```
function fn(num) {
  let num1 = num / 10;
  let num2 = num % 10;
  if (num1 < 1) {
    return num;
  } else {
    num1 = Math.floor(num1);
    return `${num2}${fn(num1)}`
  }
}
var a = fn(123456);
console.log(a, typeof a)
```

### 
```
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
// 4
// 2
// 1
```
```
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行

Foo.prototype.a = function() {
    console.log(3)
}
// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3

Foo.a = function() {
    console.log(4)
}
// 现在在 Foo 上挂载了直接方法 a ，输出值为 4

Foo.a();
// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
// # 输出 4

let obj = new Foo();
/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
2. 在新对象上挂载直接方法 a ，输出值为 2。
*/

obj.a();
// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
// # 输出 2

Foo.a();
// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
// # 输出 1
```

### Async/Await 如何通过同步的方式实现异步
Async/Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式

### 修改以下 print 函数，使之输出 0 到 99，或者 99 到 0
要求：
1. 只能修改 setTimeout 到 Math.floor(Math.random() * 1000 的代码
2. 不能修改 Math.floor(Math.random() * 1000
3. 不能使用全局变量
```
function print(n){
  setTimeout(() => {
    console.log(n);
  }, Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
  print(i);
}
```
解法：
```
function print(n){
  setTimeout(() => {
    console.log(n);
  },1, Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
  print(i);
}
```
```
function print(n){
  setTimeout(() => {
    setTimeout(() => {
      console.log(n)
    }, n * 1000)
  },Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
  print(i);
}
```
```
function print(n){
  setTimeout((function() {
    console.log(n)
    return () => {}
  })(), Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
  print(i);
}
```

### 不用加减乘除运算符，求整数的7倍
```
function fn(m) {
  let arr = new Array(m);
  return [...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr].length
}
```

### 考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素
```
function fn(m, n) {
  let arr = Array.from({length: m}, (item, key) => key + 1)
  let result = new Set();
  for (let i = 0; i < n; i++) {
    let luckDog = Math.floor(Math.random()*m);
    if (!result.has(arr[luckDog])) {
      result.add(arr[luckDog])
    } else {
      i--;
    }
  }
  return result;
}
```
由于随机从100K个数据中随机选取10k个数据，可采用统计学中随机采样点的选取进行随机选取，如在0-50之间生成五个随机数，然后依次将每个随机数进行加50进行取值，性能应该是最好的。

### 编程题，请写一个函数，完成以下功能
输入： [1,2,3,5,7,8,10]
输出：1~3,5,7~8,10
如果连续数字的话，就取连续的第一个数和最后一个数，中间用~隔开。如果不连续就用，隔开。
```
const nums1 = [1, 2, 3, 5, 7, 8, 10];
function simplifyStr(num) {
  var result = [];
  var temp = num[0]
  num.forEach((value, index) => {
    if (value + 1 !== num[index + 1]) {
      if (temp !== value) {
        result.push(`${temp}~${value}`)
      } else {
        result.push(`${value}`)
      }
      temp = num[index + 1]
    }
  })
  return result;
}
console.log(simplifyStr(nums1).join(','))
```

