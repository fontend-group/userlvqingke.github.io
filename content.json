[{"title":"前端面试题","date":"2020-06-20T09:44:19.000Z","path":"前端面试题/","text":"写React/Vue项目时，为什么要在列表组件中写key，其作用是什么？官网推荐使用key，应该理解为使用唯一的ID作为key，因为用index作为key和不带key的效果是一样的。index作为key时，每个列表在变更前后是一样的，都是直接判断sameVnode，然后复用。key的作用就是更新组件时，判断两个节点是否相同。相同就复用，不相同就删除旧的，创建新的。正是因为带有唯一的key，每次更新是都找不到唯可复用的节点，不但要销毁和创建vnode，在DOM里添加移除节点对性能影响更大。所以才会说：”不带key，可能性能更好“。因为不带key时，节点能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM的文本内容，而不是移除/添加节点，这就是文档中所说的：”刻意依赖默认行为，以获取性能上的提升“。既然如此，为什么还要建议带key呢？因为这种不带key的模式只适用于简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。 123举个例子：一个新闻列表，可以点击列表项来将其标记为已访问。可以通过tab切换到”娱乐新闻“或”社会新闻“。不带key属性的情况，在”娱乐新闻“下选中第二项，然后切换到”社会新闻“，”社会新闻“里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上唯一的新闻id作为唯一的key，那么每次渲染列表时，都会完全替代所有的组件，从而拥有正确的状态。 这只是个简单的例子，实际应用汇更复杂。带上唯一的key，虽然会增加开销，但对于用户来说，基本感受不到差别，而且能保证组件状态的正确。这应该是为什么官方推荐使用唯一id作为key的原因。 [‘1’,’2’,’3’].map(parseInt)1234567[1, NaN, NaN]Array.prototype.map() 创建一个新数组，其结果是该数组中每个元素都调用一次提供的函数后的返回值。parseInt(string, radix) 将一个字符串string转换为radix进制的整数，radix介于2~36之间模拟运行的情况：1. parseInt('1', 0) // radix为0时，且string参数不以”0x“开头，按照10进制来处理，这个时候返回12. parseInt('2', 1) // radix介于2~36之间，无法解析该字符串，返回NaN3. parseInt('3', 2) // 2进制表示的数中，最大值小于3，所以无法解析，返回NaN 什么是防抖和节流？有什么区别？如何实现？ 防抖 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次触发，则重新计算事件思路：每次触发事件时，都会取消掉之前的延时调用方法demo： 1234567891011121314function debounce(fn) &#123; let timer = null; // 创建一个标记，用来存放定时器的返回值 return function () &#123; clearTimeout(timer); // 把之前的timer移除 timer = setTimeout(() =&gt; &#123; // 创建新的timeout fn.apply(this, arguments)// 为了确保上下文环境为当前的this，不能直接使用fn(); &#125;, 300); &#125;&#125;function sayHi() &#123; console.log('防抖成功');&#125;let inp = document.querySelect('#inp');inp.addEventListener('input', debounce(sayHi)) 节流 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率思路：每次触发事件时，都判断当前是否有等待执行的延时函数demo: 1234567891011121314151617function throttle(fn) &#123; let canRun = true; // 通过闭包保存一个标记 return function () &#123; if (!canRun) &#123; return; &#125; canRun = false; setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments);// 为了确保上下文环境为当前的this，不能直接使用fn(); canRun = true;// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉 &#125;, 300) &#125;&#125;function sayHi(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight);&#125;window.addEventListener('resize', throttle(sayHi)); 介绍下Set、Map、WeakSet和WeakMap的区别？ 名称 描述 Set 1. 成员唯一，无状态且不重复； 2. 只有键值，没有键名，类似数组； 3. 可以遍历，方法有add、has、delete WeakSet 1. 成员都是对象； 2. 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不易造成内存泄漏； 3. 不能遍历，方法有add、has、delete Map 1. 本质上是键值对集合，类似集合； 2. 可以遍历，方法很多，可以跟跟中数据类型转换 WeakMap 1. 只接受对象作为键名（null除外），不接受其他类型的值作为键名； 2. 键名是弱引用，键值可以是任意值，键名所指向的对象可以被垃圾回收，此时键名是无效的； 3. 不能遍历，方法有get、set、delete、has SetES6新增的一种数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。Set是一种叫做集合的数据结构应用场景：数据重组Set本身是一个构造函数，用来生成Set数据结构12345678new Set([literable])const s = new Set();[1, 2, 3, 4, 3, 2, 1].forEach(x =&gt; s.add(x));for(let i of s) &#123; console.log(i) // 1 2 3 4&#125;// 数组去重[...new Set([1, 2, 3, 4, 3, 2, 1])] 任意数据类型都可以作为Set对象的成员Set内部判断两个值是否不同，使用的算法是”same-value-zero equality“，它类似于精确相等运算符（===），不同点：Set对象认为NaN等于自身，而精确相等运算符认为NaN不等于自身。123456const set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // &#123;NaN&#125; Set实例属性 constructor 构造函数size 包含元素的数量Set实例方法add(value) 新增元素delete(value) 存在即删除元素has(value) 判断集合中是否存在valueclear() 清空集合中所有元素Set对象与数组间的转换 1234const arr = [1, 2, 3, 4, 3, 2, 1]const set1 = new Set(arr) // &#123;1, 2, 3, 4&#125;Array.from(set1) // [1, 2, 3, 4][...set1] // [1, 2, 3, 4] 遍历Set对象的方法 keys() 返回一个集合中包含所有键的迭代器values() 返回一个集合中包含所有值得迭代器entries() 返回一个集合中包含所有键值对的迭代器forEach(callback, thisArg) 对于集合中的成员执行callback操作，没有返回值。设置thisArg，则当前的执行上下文环境就是thisArg 1234567const set2 = new Set([1, 2, 3]);console.log(set2.keys()); // SetIterator &#123;1, 2, 3&#125;console.log(set2.values()); // SetIterator &#123;1, 2, 3&#125;console.log(set2.entries()); // SetIterator &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;for(let item of set2.entries()) &#123; console.log(item); // [1, 1] [2, 2] [3, 3]&#125; Set 很容易实现交集、并集、差集12345let set3 = new Set([2, 3, 4]);let set4 = new Set([2, 5, 4]);let intersect = new Set([...set4].filter(x =&gt; set3.has(x))); // &#123;2, 4&#125;let union = new Set([...set3, ...set4]); // &#123;2, 3, 4, 5&#125;let difference = new Set([...set4].filter(x =&gt; !set3.has(x))); // &#123;5&#125; WeakSetWeakSet 允许将弱引用对象存到集合中Set和WeakSet的区别： WeakSet只能存放对象，不能存其他值；而Set都可以存WeakSet里存的是弱引用对象，在没有其他变量或属性引用该对象的时候，会被垃圾回收机制回收。WeakSet是不可以遍历的，也就无法拿到集合中的所有元素。WeakSet中的属性/方法constructor 构造函数add(value) 添加valuehas(value) 是否包含valuedelete(value) 删除valueclear() 清空WeakSet中所有的元素，注意该方法已废弃 Map 类型 集合与字典 共同点 都可以存储不重复的值 不同点 集合是以[value,value]的形式存储元素，字典以[key, value]的形式存储元素 1234567const m = new Map();let obj = &#123;p: 'nihao'&#125;m.set(obj, 'content')m.get(obj) // contentm.has(obj) // truem.delete(obj) // truem.has(obj) // false 任何具有iterator接口，且每个成员都是一个双元素数组的数据结构，都可以当做Map构造函数的参数 1234567let set5 = new Set([['foo', 1], ['bar', 2]]);let map1 = new Map(set5);map1 // &#123;\"foo\" =&gt; 1, \"bar\" =&gt; 2&#125;map1.get('bar') // 2let map2 = new Map([['baz', 3]]);map2 // &#123;\"baz\" =&gt; 3&#125;map2.get('baz') // 3 注意：只有对同一个对象的引用，Map才将其视为同一个键名 123let map3 = new Map();map3.set([a], 4);map.get([a]); // undefined Map属性 constructor 构造函数size 字典中包含元素的个数 Map操作方法 get(key) 读取字典中键名key的数据，并返回set(key, value) 向字典中添加新元素delete(key) 通过键名key，移除对应的数据has(key) 判断字典中是否存在键名key的数据clear() 将字典中所有的元素删除 Map遍历方法 keys() 将字典中包含的键名以迭代器形式返回values() 将字典中包含的键值以迭代器形式返回entries() 返回字典中所有成员的迭代器forEach(callback, thisArg) 遍历字典中所有成员 12345const map4 = new Map([['name', 'Jack'], ['desc', 'JS']]);map4 // &#123;\"name\" =&gt; \"Jack\", \"desc\" =&gt; \"JS\"&#125;map4.keys() // MapIterator &#123;\"name\", \"desc\"&#125;map4.values() // MapIterator &#123;\"Jack\", \"JS\"&#125;map4.entries() // MapIterator &#123;\"name\" =&gt; \"Jack\", \"desc\" =&gt; \"JS\"&#125; WeakMapWeakMap 是一组键值对的集合，键名弱引用对象，键值是任意数据弱引用对象，在没有其他变量或属性引用的情况下，会被垃圾回收机制收回。不可枚举WeakMap属性/方法 constructor 构造函数get(key) 读取键名key的对象，并返回set(key, value) 设置一组键名key的对象has(key) 判断是否包含键名key的对象，没有则返回undefineddelete(key) 删除键名key的对象 常见异步笔试题，写出代码执行结果123456789101112131415161718192021222324252627async foo() &#123; console.log('foo start'); await bar(); console.log('foo end');&#125;async bar() &#123; console.log('bar run');&#125;console.log('script start');setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 0)foo();new Promise((resolve, reject) =&gt; &#123; resolve('promise1'); console.log('promise2')&#125;).then(res =&gt; console.log(res))console.log('script end')// script start// foo start// bar run// promise2// script end// foo end// promise1// setTimeout 这道题主要考察的是事件循环中函数执行顺序，其中包括async、await、setTimeout、promise。下面说说涉及的知识点： 任务队列 JS分为同步任务和异步任务同步任务都在主线程上执行，形成一个执行栈主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行 根据规范，事件循环是通过任务队列的机制来进行协调的。一个Event Loop中可以有一个或多个任务队列（task queue），一个任务队列便是一系列有序任务（task）的集合；每个任务都有一个任务源（task source），源自统一任务源的task必须放在统一任务队列中。setTimeout/Promise等API便是任务源，进入任务队列的是他们指定的具体任务。 宏任务(macro)task，可以理解为每次执行栈执行的代码就是一个宏任务浏览器为了能够使得JS内部(macro)task和DOM任务能够有序执行，会在一个(macro)task执行结束后，在下一个(macro)task执行开始前，对页面进行重新渲染，流程如下： 1(macro)task --&gt; 渲染 --&gt; (macro)task --&gt; 渲染 --&gt; (macro)task 主要包含：script（整体代码）、setTimeout、setInterval、possMessage、MessageChannel、I/O、UI交互事件3. 微任务(micro)task，可以理解是在当前task执行结束后立即执行的任务，也就是说，当前任务之后，下一个任务之前，在渲染之前执行的。主要包含：Promise.then() 运行机制 执行一个宏任务（执行栈中没有就从事件队列中取）执行过程中，如果遇到微任务，便将微任务添加到微任务的任务队列中宏任务执行完毕，立即执行微任务队列中的微任务（依次执行）当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染渲染完毕，JS线程继续接管，开始下一个宏任务。 Promise和async中立即执行Promise中的代码是立即执行的，异步体现在then和catch上。async中，await之前是立即执行的，那await做了什么呢？ await做了什么await是让出线程的标志。await后面的表达式先执行一遍，将await后面的代码加入到(micro)task中，然后就跳出了整个async函数来执行后面的代码。由于async await本身就是promise+generator的语法糖。所以await后面的代码是(micro)task。12345async foo() &#123; console.log('foo start'); await bar(); console.log('foo end');&#125; 等价于1234async foo() &#123; console.log('foo start'); Promise.resolve(bar()).then(res =&gt; console.log('foo end'))&#125; 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组1Array.from(new Set(arr.flat(Infinity))).sort((a, b) =&gt; a - b) JS异步解决方案的发展历程，及优缺点 回调函数（callback）123setTimeout(() =&gt; &#123; // callback 函数体&#125;, 1000) 缺点：形成回调地狱，不能使用try、catch捕捉错误，不能return优点：解决了同步问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）回调地狱形成的原因： 缺乏顺序行：调试困难，与大脑思维方式不符嵌套函数存在耦合，牵一发动全身 PromisePromise就是为了解决callback的问题而产生的Promise实现了链式调用，每次then返回的都是一个全新的Promise对象，如果我们在then中return,return的结果回被Promise.resolve()包装优点：解决了回调地狱的问题缺点：无法取消Promise，错误需要通过回调函数来捕捉 Generator特点：可以控制函数的执行，可以配合co数据库使用123456789function *fetch() &#123; yield ajax('XXX1', () =&gt; &#123;&#125;); yield ajax('XXX2', () =&gt; &#123;&#125;); yield ajax('XXX3', () =&gt; &#123;&#125;);&#125;const fn = fetch();let result1 = fn.next();let result2 = fn.next();let result3 = fn.next(); Async/awaitasync/await是异步的终极解决方案优点：代码清晰，不用像promise写一堆then，解决了对调地狱的问题缺点：await将异步代码改造同步代码，如果多个异步操作没有依赖性而是用await会导致性能上的降低。此种情况完全可以用Promise.all();12345async function fetch() &#123; await ajax('xxx1', () =&gt; &#123;&#125;) await ajax('xxx2', () =&gt; &#123;&#125;) await ajax('xxx3', () =&gt; &#123;&#125;)&#125; 如何实现一个new123456789101112131415function _new(fn, ...arg) &#123; const obj = Object.create(fn.prototype); const ret = fn.apply(obj, arg); return ret instanceof Object ? ret : obj;&#125;let Dog = function(name) &#123; this.name = name;&#125;Dog.prototype.sayHi = function() &#123; console.log('旺旺')&#125;let obb = _new(Dog, '二哈');obb.name // '二哈'obb.sayHi() // '旺旺' 简单讲下HTTP2的多路复用简单说，就是同一个TCP连接，同一时刻可以传输多个http请求 之前是同一个连接只能使用一次，如果开启keep-alive，虽然可以使用多次，但同一时刻只能有一个http请求详细点：在HTTP/1中，每次请求都会创建一个TCP连接，也就是我们常说的3次握手4次挥手。这个过程在一次请求中占用了相当长的时间，即使开启了keep-alive，解决了多次连接的问题，但依然有两个效率上的问题：第一个，串行文件传输，请求a文件时，b文件只能等着。等待a连接到服务器，服务器处理文件，服务器返回文件，这三个步骤。队头阻塞问题。第二个，连接数过多，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个限制。假设Apache设置了最大并发数为300，那么服务器能承载的最高并发为6-8个，后面的请求就需要等待前面的某个请求处理完。HTTP/2的多路复用就是为了解决这两个性能问题。在HTTP/2中，有两个重要的概念，分别是帧（frame）和流（stream）帧代表最小的单位，每个帧会标识出属于哪个流，流也就是多个帧组成的数据流。多路复用就是一个TCP连接中可以有多个数据流。HTTP/2采用二进制格式传输，HTTP/1采用的是文本格式传输，二进制解析更高效。同域名下所有通信都在单个连接上完成，消除了多个TCP连接带来的延迟和内存消耗单连接上可以并行多个交错的请求和响应，之间互不干扰 ES5/ES6的继承除了写法以外，还有什么区别？// 自己测试的没有什么区别。。。莫非只是对ES5继承的一种封装 12345678class Super &#123;&#125;class Sub extends Super&#123; constructor(...args) &#123; super(...args); // 等价于 Super.constructor.call(this, ...args) &#125;&#125;const sub = new Sub();sub.__proto__ === Super; 子类可以通过proto直接寻址到父类 123456function Super () &#123;&#125;function Sub () &#123;&#125;Sub.prototype = new Super();Sub.prototype.constructor = Sub;var sub = new Sub();sub.__proto__ === Function.prototype; 而通过ES5的方式，sub.proto === Function.prototype 介绍下模块安装机制，为什么输入npm install就可以自动安装对应的模块？安装机制： 发出npm install指令 查询node_modules目录之中是否已存在指定的模块 若存在不在安装若不存在 npm向registry查询模块压缩包的网址下载压缩包，存在根目录下.npm目录里解压压缩包到当前的项目node_modules目录里 介绍下重绘和回流（Repaint &amp; Reflow），以及如何优化 浏览器渲染机制 浏览器采用流式布局模型（Flow Based Layout）浏览器会把html解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就成了渲染树（Render Tree）有了Render Tree，我们就知道所有节点的样式啦，然后计算他们在页面的大小和位置，最后把节点绘制到页面上。浏览器对Render Tree的计算通常只需要遍历一遍即可完成，但table及其内部元素除外，他们可能需要计算多次，通常要花3倍于同等元素的时间，这也是为什么要避免使用table的原因之一。 重绘由于节点的样式发生改变而不影响布局，称为重绘。例如：color、background-color、visibility重绘的代价昂贵，浏览器必须验证DOM上其他节点的可见性。 回流节点的几何属性需要改变且影响了布局，称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（乃至整个页面）的布局更新。一个节点的回流，可能导致其子节点以及DOM中紧随其后的节点、祖先节点元素的回流。大部分回流导致页面重新渲染。 重绘、回流的关系回流必会发生重绘，重绘不一定发生回流。 浏览器优化现代浏览器通过队列机制来批量更新布局，浏览器会把修改操作放到队列里，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你回去布局信息的时候，队列中可能有影响布局的属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘，确保返回正确的值。主要包括以下信息或方法：1234561. offsetTop、offsetLeft、offsetWidth、offsetHeight;2. scrollTop、scrollLeft、scrollWidth、scrollHeight;3. clientTop、clientLeft、clientWidth、clientHeight;4. width、height5. getComputedStyle()6. getBoundingClientRect() 使用上述属性，浏览器都会强制刷新队列 减少回流与重绘CSS 使用visibility替换display: none，因为前者只会引起重绘，后者会引起回流避免使用table布局，可能很小的一个改动，就会造成整个table的重新布局尽可能在DOM树的最末端改变class，以减少回流的影响避免设置多层内联样式，CSS选择符从右往左匹配查找，避免节点层级过多。将动画效果应用到position为absolute、fixed元素上。避免影响其他元素的布局。同时控制动画速度，可以使用requestAnimationFrame使用GPU硬件加速JS避免频发操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改。避免频发操作DOM，创建一个documentFragement，在它上面应用所有DOM操作，最后再把它添加到文档中。避免频繁读取引起回流/重绘的属性，如果需要多次使用，就用一个变量缓存起来。 介绍下观察者模式和订阅-发布模式的区别，各自使用场景？可以简单理解为：观察者模式：没有中间商赚差价订阅-发布模式：有中间商赚差价 联系发布-订阅模式是观察模式的一种变体，发布-订阅模式只是将一部分功能抽象成一个独立的ChangeManager。 意图都是某个对象（subject,publisher）改变，使依赖于它的多个对象（observers,subscribers）得到通知。 区别与适用场景总的来说，发布-订阅模式适合更复杂的场景。在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？在「多对一」或「多对多」的场景下，一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是所有发布者都更新完毕后，再通知订阅者？这些逻辑都可以放在ChangeManager里。 介绍模块化发展历程模块化主要用来抽离公共代码，隔离作用域，避免变量冲突。IIFE： 使用自执行函数编写模块化 特点：在一个单独的函数作用域中执行代码，避免变量冲突AMD：使用requireJS来编写模块特点：依赖必须提前声明好CMD：使用seaJS来编写模块特点：支持动态引入依赖文件CommonJS：nodejs中自带的模块化。UMD：兼容AMD、CommonJS等模块化语法ES Modules：ES6引入的模块化，支持import引入另一个js文件接下来重点说一下CommonJS和ES ModulesCommonJS:特点：require、exports、module.exportsCommonJS一般用在服务端或node用来同步加载模块，处理模块依赖发生在代码运行阶段，不适合浏览器端做异步加载。exports实际上是一个对module.exports的引用： 123exports.add = 'xxx';等同于module.exports.add = 'xxx' 不能直接给exports赋值，否则会断开与module.exports的连接。 ES6 Module 特点：import、exportES6模块化不是对象，import会在JavaScript引擎静态分析，在编译时就引入代码，而并非在代码运行时引入代码。因此也不适合异步加载。在Html中如果需要引入模块，需要这样写： 1&lt;script type=\"module\" src=\"./module.js\"&gt;&lt;/script&gt; 优势： 死代码检查和排除，我们可以用静态分析工具检测出哪些模块没有被调用到。去掉这些不会使用到的模块，减下包的体积。编译器优化，在CommonJS等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象。而ES6 Module直接导入变量，减少了引用层级，代码效率更高CommonJS 与 ES6 Module的区别：CommonJS在引入时是加载整个模块，是生成一个对象，然后再从这个生成的对象上读取方法和属性。ES Module不是对象，而是通过export暴露的代码块，在import时使用静态命令的方法引入指定的输出代码块，并在import语句出执行这个要输出的代码，而不是直接加载整个模块CommonJS引用后是一个值的拷贝ES Module引用后是一个值得动态映射ES6 export/export default/import js中的排序算法冒泡排序时间复杂度：O(n^2) 1234567891011121314function bobbleSort1(arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; let temp; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 快速排序时间复杂度：O(nlogn) 1234567891011121314function quickSort(arr) &#123; if (arr.length &lt; 2) return arr; let middleIndex = Math.floor(arr.length / 2); let middleValue = arr.splice(middleIndex, 1)[0]; let left = [], right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; middleValue) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(middleValue, quickSort(right))&#125; 请把两个数组[A1,A2,B1,B2,C1,C2,D1,D2]和[A,B,C,D]，合并成[A1,A2,A,B1,B2,B,C1,C2,C,D1,D2,D]1234567891011function sort(arr1, arr2) &#123; let arr = [...arr1]; for (let i = 0; i &lt; arr2.length; i++) &#123; let temp = arr2[i] + '2'; let index = arr.indexOf(temp); if (index &gt; -1) &#123; arr.splice(++index,0,arr2[i]) &#125; &#125; return arr;&#125; 12345678910111213function sortDemo(arr1, arr2) &#123; let arr = [...arr1]; for(let i = 0; i &lt; arr2.length; i++) &#123; arr.push(arr2[i]+'3') &#125; arr = arr.sort().map(item =&gt; &#123; if (item.includes('3')) &#123; return item.split('')[0] &#125; return item; &#125;) return arr;&#125; 改造下面代码，使之输出0-9，写出你能想到的所有解法。利用let特性，每次循环过程中，let会在当前的块级作用域中创建文法环境，该环境中包含当前for循环的变量i； 12345for(let i = 0; i &lt; 10; i++) &#123; setTimeout(()=&gt; &#123; console.log(i) &#125;, 1000)&#125; 利用setTimeout的第三个参数，会作为回调参数的第一个参数传入； 12345for(var i = 0; i &lt; 10; i++) &#123; setTimeout((i) =&gt; &#123; console.log(i) &#125;, 1000, i)&#125; 利用bind部分执行的特性； 12345for(var i = 0; i &lt; 10; i++) &#123; setTimeout((i =&gt; &#123; console.log(i) &#125;).bind(Object.create(null), i), 1000)&#125; 利用函数自执行的方式，把当前for循环中的传进去，构成块级作用域。 1234567for(var i = 0; i &lt; 10; i++) &#123; (function(i)&#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000) &#125;)(i)&#125; 聊聊Redux和Vuex的设计思想共同点：首先两者都是处理全局状态的工具库，大致实现思想都是：全局state保存状态—&gt;dispatch(action)—&gt;reducer(vuex中的mutation)—&gt;生成newState;整个状态为同步操作。不同点：最大的区别在于处理异步的不同，vuex中多了异步commit操作，在action之后commit(mutation)之前处理异步，而redux里面通过中间件处理。知乎Vuex和Redux 执行下面代码，输出结果，解释原因12345678910var b = 10;(function b() &#123; b = 20; console.log(b);&#125;)()// 输出的结果：ƒ b() &#123; b = 20; console.log(b)&#125; 原因：作用域可以理解为上下文中声明的变量和作用的范围。包括块级作用域和函数作用域、全局作用域。特性：声明提前，一个声明在函数体内都是可见的，函数声明优先于变量声明。在非匿名自执行函数中，函数变量为制度状态，无法修改。 使用迭代的方式实现flatten函数123456function flatten(arr) &#123; while(arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 12345678910111213function flatten(arr) &#123; let arrs = [...arr]; let newArr = []; while(arrs.length) &#123; let item = arrs.shift(); if (Array.isArray(item)) &#123; arrs.unshift(...item); &#125; else &#123; newArr.push(item); &#125; &#125; return newArr;&#125; 1234567891011function flatten(arr) &#123; let arrs = []; arr.map(item =&gt; &#123; if (Array.isArray(item)) &#123; arrs.push(...flatten(item)); &#125; else &#123; arrs.push(item); &#125; &#125;) return arrs;&#125; 下面程序怎么打印出1来1234var a = ?;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; 考察的是==隐式类型转换，我们重写toString方法就可以了，转换时会调用对象本身的toString或valueOf方法 123456789var a = &#123; i: 1, toString() &#123; return a.i++; &#125;&#125;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; 123456789var a = &#123; i: 1, valueOf() &#123; return a.i++; &#125;&#125;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; 12345var a = [1, 2, 3];a.toString = a.shift;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(1);&#125; 介绍下BFC及其应用BFC：块级格式上下文，是页面盒模型布局中的一种css渲染方式，相当于一个独立的容器，里面的元素和外面的元素互不影响。创建BFC的方式： html根元素float浮动绝对定位overflow不为visibledisplay为表格布局或弹性布局作用：清除浮动，防止同一BFC容器中相邻元素间外边距重叠 在Vue中，子组件为何不能修改父组件传进来的prop，如果修改了，Vue是如何监控到属性的修改并给出警告的？原因：单项数据流，易于检测数据的流动，出现错误可以更快速的定位到错误发生的位置。如果修改了，Vue是如何健康到属性的修改并给出警告的？ 123456789101112131415161718192021if (process.env.NODE_ENV !== 'production') &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"), vm ); &#125; defineReactive$$1(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( \"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm ); &#125; &#125;);&#125; 在initProps的时候，在defineReative时通过判断当前是否在开发环境，如果是开发环境，会在触发set时判断是否此key处于updatingChildren中被修改，如果不是，则说明修改来自子组件，触发warning提示。 执行下面代码，输出的结果是？1234567891011var a = 10;(function() &#123; console.log(a); a = 5; console.log(window.a); var a = 20; console.log(a);&#125;)()// undefined// 10// 20 实现一个sleep函数，比如sleep(1000)意味着要等待1000毫秒，可从Promise、Generator、Async/await123456789function sleep(time) &#123; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('执行啦'); &#125;, time) &#125;).then(res =&gt; &#123; console.log(res) &#125;)&#125; 12345678function* sleep(time) &#123; yield new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('执行完了') &#125;, time) &#125;)&#125;sleep(1000).next().value.then(res =&gt; console.log(res)) 123456789async function sleep(time) &#123; const result = await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('执行完了'); &#125;, time) &#125;) console.log(result);&#125; 介绍HTTPS握手的过程 客户端使用HTTPS的url访问web服务器，要求与服务器建立ssl连接 web服务器收到请求后，会将网站的证书（包含公钥）传送一份给客户端 客户端收到网站证书后，检查证书的颁发机构以及过期时间，如果没有问题就随机产生一个秘钥 客服端利用公钥将会话秘钥加密，并传送给服务端，服务端利用自己的私钥解密出会话秘钥 之后客户端与服务端使用会话秘钥加密传输 HTTPS握手过程中，客户端如何验证证书的合法性？（1）首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充 输出以下代码的结果，并解释原因1234567891011121314151617var a = &#123; '2': 3, '3': 4, length: 2, splice: Array.prototype.splice, push: Array.prototype.push&#125;a.push(1);a.push(2);console.log(a);// Object(4)// 2: 1// 3: 2// length: 4// push: ƒ push()// splice: ƒ splice()// __proto__: Object 涉及知识点： 类数组（ArrayLike）：一组数据，由数组来存，但是如果要对这组数据进行扩展，会影响到数组原型，ArrayLike的出现则提供了一个中间数据桥梁，ArrayLike有数组的特性， 但是对ArrayLike的扩展并不会影响到原生的数组。 push方法：push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length 不存在时，将会创建它。唯一的原生类数组（array-like）对象是 Strings，尽管如此，它们并不适用该方法，因为字符串是不可改变的。 对象转数组的方式：Array.from()、splice()、concat()等 Vue中双向数据绑定和Vuex是否冲突在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案：1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值2、使用带有setter的双向绑定计算属性。见以下例子（来自官方文档）： 12&lt;input v-model=\"message\"&gt;computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125; &#125; cal和apply有什么区别，哪个性能更好些？ Function.prototype.apply和Function.prototype.call 的作用是一样的，区别在于传入参数的不同； 第一个参数都是，指定函数体内this的指向； 第二个参数开始不同，apply是传入带下标的集合，数组或者类数组，apply把它传给函数作为参数，call从第二个开始传入的参数是不固定的，都会传给函数作为参数。 call比apply的性能要好，平常可以多用call, call传入参数的格式正是内部所需要的格式 为什么通常在发送数据埋点请求的时候通常使用的是1*1像素的透明的gif图片？作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的1x1 像素的透明 gif 图片；why? 没有跨域问题，一般这种上报数据，代码要写通用的；（排除ajax） 不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报） 在所有图片中，体积最小；（比较PNG/JPG） 能够完成整个 HTTP 请求+响应（尽管不需要响应内容） 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据 跨域友好 执行过程无阻塞 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好 GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节） 实现(5).add(3).minus(2)1234567Number.prototype.add = function(n) &#123; return this.valueOf() + n;&#125;Number.prototype.minus = function(n) &#123; return this.valueOf() - n;&#125;(5).add(3).minus(2) Vue的响应式原理中Object.defineProperty有什么缺陷？为什么在3.0中采用了Proxy，抛弃了Object.defineProperty? Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 怎么让一个div垂直水平居中。123&lt;div class=\"parent\"&gt; &lt;div class=\"child\" style=\"width: 50px;height: 50px;background: yellow;\"&gt;&lt;/div&gt;&lt;/div&gt; 12345div.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 123456div.parent &#123; display: flex;&#125;div.child &#123; margin: auto;&#125; 123456789101112div.parent &#123; position: relative; height: 100px;&#125;div.child &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 12345678910div.parent &#123; position: relative; height: 100px;&#125;div.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-25px, -25px);&#125; 1234567891011div.parent &#123; position: relative; height: 100px;&#125;div.child &#123; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -25px;&#125; 1234567div.parent &#123; display: grid;&#125;div.child &#123; justify-self: center; align-self: center;&#125; 执行下面代码，给出输出结果，并解释为什么？1234567var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;console.log(a.x);console.log(b.x);// undefined// &#123;n: 2&#125; 首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。 1b.x = a = &#123;n: 2&#125; 冒泡排序如何实现？时间复杂度是多少？还可以如何改进？时间复杂度：n^2 123456789101112131415function buddleSort(arr) &#123; console.time('yes') if (!Array.isArray(arr)) return; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; console.timeEnd('yes') return arr;&#125; 改进后 12345678910111213141516171819function buddleSort(arr) &#123; console.time('abc1'); if (!Array.isArray(arr)) return; let i = arr.length - 1; while(i &gt; 0) &#123; let pos = 0; for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; pos = j; let temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; i = pos; &#125; console.timeEnd('abc1'); return arr;&#125; 某公司1到12月份的销售额存在一个对象里123let data = &#123;1: 222, 2: 123, 5: 888&#125;;const arr = Array.from(&#123;length: 12&#125;).map((_, index) =&gt; data[index + 1] || null);console.log(arr); 要求设计LazyMan类，实现以下功能。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class LazyManClass &#123; constructor(name) &#123; this.name = name; this.taskList = []; console.log(`Hi I am $&#123;name&#125;`); setTimeout(() =&gt; &#123; this.next(); &#125;, 0) &#125; sleep(time) &#123; let that = this; let fn = (function(time) &#123; return function() &#123; setTimeout(() =&gt; &#123; console.log(`等待了$&#123;time&#125;秒...`); that.next(); &#125;, time * 1000) &#125; &#125;)(time) this.taskList.push(fn); return this; &#125; eat(something) &#123; let that = this; let fn = (function(something) &#123; return function() &#123; console.log(`I am eating $&#123;something&#125;`) that.next(); &#125; &#125;)(something) this.taskList.push(fn); return this; &#125; sleepFirst(time) &#123; let that = this; let fn = (function(time) &#123; return function() &#123; setTimeout(() =&gt; &#123; console.log(`等待了$&#123;time&#125;秒...`); that.next(); &#125;, time * 1000) &#125; &#125;)(time) this.taskList.unshift(fn); return this; &#125; next() &#123; if (this.taskList.length === 0 ) return; let fn = this.taskList.shift(); fn &amp;&amp; fn(); &#125;&#125;function LazyMan(name) &#123; return new LazyManClass(name);&#125; 分析比较opacity:0、visibility: hidden、display: none优劣和适用场景？1display: none; DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间； 事件监听：无法进行 DOM 事件监听； 性能：动态改变此属性时会引起重排，性能较差； 继承：不会被子元素继承，毕竟子类也不会被渲染； transition：transition 不支持 display。1visibility: hidden; DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间； 事件监听：无法进行 DOM 事件监听； 性 能：动态改变此属性时会引起重绘，性能较高； 继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏； transition：transition 不支持 display。1opacity: 0; DOM 结构：透明度为 100%，元素隐藏，占据空间； 事件监听：可以进行 DOM 事件监听； 性 能：提升为合成层，不会触发重绘，性能较高； 继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏； transition：transition 不支持 opacity。 箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 不可以使用 new 命令，因为：没有自己的 this，无法调用 call，apply。没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 protonew操作符大致过程是这样的：123456789101112function newFunc(father, ...rest) &#123; var result = &#123;&#125;; result.__proto__ = father.prototype; var result2 = father.apply(result, rest); if ( (typeof result2 === 'object' || typeof result2 === 'function') &amp;&amp; result2 !== null ) &#123; return result2; &#125; return result;&#125; 给定两个数组，写一个方法计算他们的交集。12345678910let arr1 = [1,4,5,6,4,6], arr2 = [2,4,6,8,4,6];function fn(arr1, arr2) &#123; return arr1.filter((item, index) =&gt; &#123; if (arr2.includes(item)) &#123; return item; arr2.splice(index, 1); &#125; &#125;)&#125;fn(arr1, arr2) 哈希表，时间复杂度O(m+n),m:arr1的长度，n:arr2的长度 123456789101112131415161718function intersect(arr1, arr2) &#123; const map = &#123;&#125;; const res = []; for (let n of arr1) &#123; if (map[n]) &#123; map[n]++; &#125; else &#123; map[n] = 1; &#125; &#125; for (let n of arr2) &#123; if (map[n] &gt; 0) &#123; res.push(n); map[n]--; &#125; &#125; return res;&#125; 已知如下代码，如何修改才能使图片宽度为300px？注意下面代码不可修改。src1234&#96;&#96;&#96;img &#123; max-width: 300px;&#125; 1234img &#123; box-sizing: border-box; padding-right: 180px;&#125; 123img &#123; transform: scale(0.625, 0.625);&#125; 123456789101112img &#123; animation: imgWH 0s forwards;&#125;@keyframes imgWH &#123; from &#123; width: 300px; &#125; to &#123; width: 300px; &#125;&#125;利用CSS动画的样式优先级高于!important的特性 介绍下如何实现token加密jwt举例 需要一个secret（随机数） 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端前端每次request在header中带上token 后端用同样的算法解密 这边也是这么做的，后端根据token来查权限和是否登录以及失效等 如何设计实现无缝轮播无限轮播基本插件都可以做到,不过要使用原生代码实现无缝滚动的话我可以提点思路,因为轮播图基本都在ul盒子里面的li元素,首先获取第一个li元素和最后一个li元素,克隆第一个li元素,和最后一个li元素,分别插入到lastli的后面和firstli的前面,然后监听滚动事件,如果滑动距离超过x或-x,让其实现跳转下一张图或者跳转上一张,(此处最好设置滑动距离),然后在滑动最后一张实现最后一张和克隆第一张的无缝转换,当到克隆的第一张的时候停下的时候,,让其切入真的第一张,则实现无线滑动,向前滑动同理 模拟实现一个Promise.finally1234567Promise.prototype.finally = function(callback) &#123; let p = this.constructor; return p.then( value =&gt; Promise.resolve(callback()).then(() =&gt; value), reason =&gt; Promise.resolve(callback()).then(() =&gt; reason) )&#125; a.b.c.d和a[‘b’][‘c’][‘d’]，哪个性能更高？应该是 a.b.c.d 比 a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;] 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。这个题从AST角度看就很简单了，a[&#39;b&#39;][&#39;c&#39;][&#39;d&#39;]和a.b.c.d，转换成AST前者的的树是含计算的，后者只是string literal，天然前者会消耗更多的计算成本，时间也更长 ES6代码转换为ES5代码实现思路？题目说的是 ES6，所以不考虑 .jsx、.ts 这类 js 拓展语言。ES6 转 ES5 目前行业标配是用 Babel，转换的大致流程如下： 解析：解析代码字符串，生成 AST；转换：按一定的规则转换、修改 AST；生成：将修改后的 AST 转换成普通代码。如果不用工具，纯人工的话，就是使用或自己写各种 polyfill 了。补充说明： .vue文件通过webpack的vue-loader分析出script style template 再走上面的ES6转ES5流程jsx通过babel插件转js语法再走ES6转ES5ts通过tsc结合tsconfig.json直接转ES5 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]123456789101112131415function fn() &#123; let arr = Array.from(&#123;length: 10&#125;).map(item =&gt; item = Math.random().toFixed(2)*100) console.log(arr) let arr1 = [...new Set(arr)].sort((a, b) =&gt; a - b); console.log(arr1) let arr2 = [] arr1.forEach(item =&gt; &#123; let key = parseInt(item / 10); if (!arr2[key]) &#123; arr2[key] = []; &#125; arr2[key].push(item) &#125;) console.log(arr2)&#125; 实现0.5像素边框/如何解决移动端Retina屏1像素问题 伪元素 + transform scaleY(0.5) border-image background-image box-shadow 12345678910function processString(str) &#123; let arr = str.split('').map(item =&gt; &#123; if (item === item.toLowerCase()) &#123; return item.toUpperCase(); &#125; else &#123; return item.toLowerCase() &#125; &#125;); return arr.join('');&#125; 1'AbcDefGh'.replace(/[a-zA-Z]/g,function(a)&#123; return /[a-z]/.test(a)?a.toUpperCase():a.toLowerCase(); &#125;); 介绍webpack热更新原理，是如何做到在不刷新浏览器的前提下更新页面的？ 当修改了一个或多个文件； 文件系统接收更改并通知webpack； webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新； HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp； HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。 关于webpack的热更新原理，面试官比较想听到的是工作流程和关键点，非“流水账”式的源码分析。我认为可以这样的介绍： 首先，介绍webpack-dev-server:webpack-dev-server 主要包含了三个部分： webpack: 负责编译代码 webpack-dev-middleware: 主要负责构建内存文件系统，把webpack的 OutputFileSystem 替换成 InMemoryFileSystem。同时作为Express的中间件拦截请求，从内存文件系统中把结果拿出来。 express：负责搭建请求路由服务。 其次，介绍工作流程: 启动dev-server，webpack开始构建，在编译期间会向 entry 文件注入热更新代码； Client 首次打开后，Server 和 Client 基于Socket建立通讯渠道； 修改文件，Server 端监听文件发送变动，webpack开始编译，直到编译完成会触发”Done”事件； Server通过socket 发送消息告知 Client； Client根据Server的消息（hash值和state状态），通过ajax请求获取 Server 的manifest描述文件； Client对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块； Client获取到新的JS模块后，会更新 modules tree并替换掉现有的模块； 最后调用 module.hot.accept() 完成热更新； 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。12345function fn(s, t) &#123; if (s.length &lt; t.length) return -1; let arr = s.split(t); return arr.length &gt; 1 ? arr[0].length : -1;&#125; 123456789function fn(s, t) &#123; if (s.length &lt; t.length) return -1; for(let i = 0,len = s.length - t.length; i &lt; len; i++) &#123; if (s.substr(i, t.length) === t) &#123; return i; &#125; &#125; return -1;&#125; 12345678910111213141516function fn() &#123; let arrs = new Array(10000000); console.time('for'); for (let i = 0; i &lt; arrs.length; i++) &#123; &#125;; console.timeEnd('for'); console.time('forEach'); arrs.forEach((arr) =&gt; &#123; &#125;); console.timeEnd('forEach');&#125; 在10万这个级别下， forEach 的性能是 for的十倍 12for: 2.263msforEach: 0.254ms 在100万这个量级下， forEach 的性能是和for的一致 12for: 2.844msforEach: 2.652ms 在1000万级以上的量级上 ， forEach 的性能远远低于for的性能 12for: 8.422msforEach: 30.328m for循环是常见的循环语句forEach和map是在ES5出的，但是在性能上后者不如前者，在次数少的情况下forEach会比for要快，但是到达了十万次时forEach明显就跟不上了。在大数据量的情况下for循环的兼容性和多环境运行表现比较优秀，forEach的优点是在数据量小时占优势，语义话更简洁。循环时没有返回值。map和forEach差不多但是map循环有返回值 介绍下BFC、IFC、GFC和FFC BFC（Block formatting contexts）：块级格式上下文页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发BFC的元素有float、position、overflow、display：table-cell/ inline-block/table-caption ；BFC有什么作用呢？比如说实现多栏布局’ IFC（Inline formatting contexts）：内联格式上下文IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。那么IFC一般有什么用呢？水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。 GFC（GrideLayout formatting contexts）：网格布局格式化上下文当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。 FFC（Flex formatting contexts）:自适应格式上下文display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。 使用JavaScript Proxy实现简单的双向数据绑定。12345678910111213141516171819202122232425&lt;body&gt; hello world &lt;input type=\"text\" id=\"model\"&gt; &lt;p id=\"word\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; const inputEl = document.querySelector('#model'); const pEl = document.querySelector('#word'); var obj = &#123;&#125;; const newObj = new Proxy(obj, &#123; get(target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;, set(target, key, value, receiver) &#123; if (key === 'text') &#123; inputEl.value = value; pEl.innerHtml = value; &#125; return Reflect.set(target, key, value, receiver) &#125; &#125;) inputEl.addEventListener('keyup', e =&gt; &#123; newObj.text = e.target.value; &#125;)&lt;/script&gt; 数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少1234567891011function fn() &#123; let arr = new Array(100000); console.time('first'); const item = arr[0]; console.timeEnd('first'); console.time('end'); const item1 = arr[99999]; console.timeEnd('end');&#125;// first: 0.0029296875ms// end: 0.001953125ms 输出下面代码运行的结果这题考察的是对象的键名的转换： 对象的键名只能是字符串和 Symbol 类型。 其他类型的键名会被转换成字符串类型。 对象转字符串默认会调用 toString 方法。123456789// example 1var a=&#123;&#125;, b='123', c=123;a[b]='b';// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。a[c]='c'; // 输出 cconsole.log(a[b]); 1234567891011// example 2var a=&#123;&#125;, b=Symbol('123'), c=Symbol('123'); // b 是 Symbol 类型，不需要转换。a[b]='b';// c 是 Symbol 类型，不需要转换。任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。a[c]='c';// 输出 bconsole.log(a[b]); 12345678910111213// example 3var a=&#123;&#125;, b=&#123;key:'123'&#125;, c=&#123;key:'456'&#125;; // b 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。a[b]='b';// c 不是字符串也不是 Symbol 类型，需要转换成字符串。// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。a[c]='c'; // 输出 cconsole.log(a[b]); 旋转数组算法题给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3输出: [5, 6, 7, 1, 2, 3, 4]解释:向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4] 123456function fn(arr, k) &#123; for(let i = 0; i &lt; k; i++) &#123; arr.unshift(arr.pop()) &#125; return arr;&#125; 123function fn(arr, k) &#123; let num = arr.length % k;&#125; Vue 的父组件和子组件生命周期钩子执行顺序是什么 加载渲染过程1父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 子组件更新过程1父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 父组件更新过程1父beforeUpdate-&gt;父updated 销毁过程1父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed 介绍下 Promise.all 使用、原理实现及错误处理1234567891011121314151617181920212223Promise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; if (!Array.isArray(promises)) &#123; return reject(new TypeError('argument must be an array')) &#125; var countNum = 0; var promiseNum = promises.length; var resolvedValue = new Array(promiseNum); for(var i = 0; i &lt; promiseNum; i++) &#123; (function(i) &#123; Promise.resolve(promises[i]).then(res =&gt; &#123; countNum++; resolvedValue[i] = res; if (countNum === promiseNum) &#123; return resolve(resolvedValue) &#125; &#125;, err =&gt; &#123; return reject(err) &#125;) &#125;)(i) &#125; &#125;)&#125; 打印出 1 - 10000 之间的所有对称数 例如 121、1331 等12345678910function fn() &#123; let result = []; for(let i = 1; i &lt; 10000; i++) &#123; let item = i + ''; if (item.length &gt; 1 &amp;&amp; item === item.split('').reverse().join('')) &#123; result.push(item * 1) &#125; &#125; console.log(result)&#125; 12345function fn() &#123; return [...Array(10000).keys()].filter(item =&gt; &#123; return item.toString().length &gt; 1 &amp;&amp; item === item.toString().split('').reverse().join('')*1 &#125;)&#125; 算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。1234567891011function fn(arr) &#123; if (!Array.isArray(arr)) return; let zeroArr = []; let list = arr.filter(item =&gt; &#123; if (item === 0) &#123; zeroArr.push(0); &#125; return item !== 0 &#125;) return [...list, ...zeroArr]&#125; 1234567891011121314function fn(arr) &#123; if (!Array.isArray(arr)) return; let len = arr.length; let j = 0, i = 0; for(i = 0; i &lt; len - j; i++) &#123; if (arr[i] === 0) &#123; arr.push(0); arr.splice(i, 1); i--; j++; &#125; &#125; return arr;&#125; var、let 和 const 区别的实现原理是什么 var声明的变量会挂载在window上，而let和const声明的变量不会123456var a = 100;let b = 100;const c = 100;console.log(a, window.a); // 100 100console.log(b, window.b); // 100 undefinedconsole.log(c, window.c); // 100 undefined var声明变量存在变量提升，let和const不存在变量提升123456console.log(a); // undefinedvar a = 100;console.log(b); // Uncaught ReferenceError: b is not definedlet b = 100;console.log(c); // Uncaught ReferenceError: Cannot access 'c' before initializationconst c = 100; let和const声明形成块作用域，而var不存在此作用域12345678&#123; var a = 100; let b = 100; const c = 100;&#125;console.log(a); // 100console.log(b); // Uncaught ReferenceError: b is not definedconsole.log(c); // Uncaught ReferenceError: c is not defined 同一作用域下let和const不能声明同名变量，而var可以123456var a = 100;let b = 100;const c = 100;var a = 200;let b = 200; // Uncaught SyntaxError: Identifier 'b' has already been declaredconst c = 200; // Uncaught SyntaxError: Identifier 'c' has already been declared let、const存在暂存死区12345var a = 100;&#123; a = 200; // Uncaught ReferenceError: Cannot access 'a' before initialization let a = 300;&#125; const 一旦声明必须赋值,不能使用null占位。声明后不能再修改如果声明的是复合类型数据，可以修改其属性 我们就从声明过程，内存分配，和变量提升这三点来看这三者之间的区别。 一.声明过程var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行const、class都是同let一样的道理比如解析如下代码步骤： {// 没用的第一行// 没用的第二行console.log(a) // 如果此时访问a报错 a is not definedlet a = 1}步骤： 发现作用域有let a，先注册个a，仅仅注册没用的第一行没用的第二行a is not defined，暂时性死区的表现假设前面那行不报错，a初始化为undefineda赋值为1对比于var，let、const只是解耦了声明和初始化的过程，var是在任何语句执行前都已经完成了声明和初始化，let、const仅仅是在任何语句执行前只完成了声明。 二.内存分配var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针 let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错 const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性 三.变量提升let const 和var三者其实会存在变量提升 let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。var的创建和初始化过程都提升了，所以在赋值前访问会得到undefinedfunction 的创建、初始化、赋值都被提升了 请实现一个 add 函数，满足以下功能。123456add(1); // 1add(1)(2); // 3add(1)(2)(3)； // 6add(1)(2, 3); // 6add(1, 2)(3); // 6add(1, 2, 3); // 6 1234567891011function add() &#123; let args = Array.from(arguments); let fn = function() &#123; let fn_args = Array.from(arguments); return add.apply(null, args.concat(fn_args)) &#125; fn.toString = function() &#123; return args.reduce((res, cur) =&gt; res + cur) &#125; return fn;&#125; 算法题之「两数之和」给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 12345678910function fn(arr, target) &#123; let len = arr.length; for(let i = 0; i &lt; len; i++) &#123; for(let j = 0; j &lt; len; j++) &#123; if (i !== j &amp;&amp; arr[i] + arr[j] === target) &#123; return [i, j] &#125; &#125; &#125;&#125; 在输入框中如何判断输入的是一个正确的网址实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度设计并实现 Promise.race()12345678910Promise._race = function (promises) &#123; if (!Array.isArray(promises)) &#123; return new TypeError('args is not Array'); &#125; return new Promise((resolve, reject) =&gt; &#123; for(let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then(resolve, reject) &#125; &#125;)&#125; 实现模糊搜索结果的关键词高亮显示我的大概思路是，用正则替换掉关键词。 12let panter = new RegExp(关键词, 'g')该行字符串.replace(panter, '&lt;b style=\"color: #2D7BFF\"&gt;' + 关键词 + '&lt;/b&gt;') ps:如果是vue项目，直接与v-html结合使用更爽哦~ 介绍下 HTTPS 中间人攻击https协议由 http + ssl 协议构成，具体的链接过程可参考SSL或TLS握手的概述中间人攻击过程如下： 服务器向客户端发送公钥。 攻击者截获公钥，保留在自己手上。 然后攻击者自己生成一个【伪造的】公钥，发给客户端。 客户端收到伪造的公钥后，生成加密hash值发给服务器。 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。 同时生成假的加密hash值，发给服务器。 服务器用私钥解密获得假秘钥。 服务器用加秘钥加密传输信息防范方法：服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性 已知数据格式，实现一个函数 fn 找出链条中所有的父级 id给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n))123456789101112function fn(arr1, arr2) &#123; let arr = arr1.concat(arr2); let mid = Math.floor(arr.length/2); arr = arr.sort((a, b) =&gt; a - b) if (arr.length % 2 === 0) &#123; console.log(arr, mid, 'even') return (arr[mid - 1] + arr[mid]) / 2; &#125; else &#123; console.log(arr, mid, 'single') return arr[mid]; &#125;&#125; vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？首先我们需要知道事件代理主要有什么作用？ 事件代理能够避免我们逐个的去给元素新增和删除事件 事件代理比每一个元素都绑定一个事件性能要更好从vue的角度上来看上面两点: 在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了 在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理 模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况定制需求如下：1、循环引用2、Symbol 类型拷贝 1234567891011121314function deepCopy(obj, map = new WeekMap()) &#123; if (obj === null || typeof obj !== 'object') return obj; // 循环引用 if (map.has(obj)) return map.get(obj); let cobj = Array.isArray(obj) ? [] : &#123;&#125;; map.set(obj, cobj); // 获取对象中所有属性名(包括Symbol) let keys = [...Object.keys(obj), ...Object.getOwnPropertySymbol(obj)] let len = keys.length; while(len--)&#123; cobj[keys[len]] = deepCopy(obj[keys[len]], map) &#125; return cobj;&#125; 介绍下前端加密的常见场景和方法首先，加密的目的，简而言之就是将明文转换为密文、甚至转换为其他的东西，用来隐藏明文内容本身，防止其他人直接获取到敏感明文信息、或者提高其他人获取到明文信息的难度。通常我们提到加密会想到密码加密、HTTPS 等关键词，这里从场景和方法分别提一些我的个人见解。 场景-密码传输前端密码传输过程中如果不加密，在日志中就可以拿到用户的明文密码，对用户安全不太负责。这种加密其实相对比较简单，可以使用 PlanA-前端加密、后端解密后计算密码字符串的MD5/MD6存入数据库；也可以 PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行MD5/MD6，全程密码明文不出现在程序中。 PlanA使用 Base64 / Unicode+1 等方式加密成非明文，后端解开之后再存它的 MD5/MD6 。 PlanB直接使用 MD5/MD6 之类的方式取 Hash ，让后端存 Hash 的 Hash 。 场景-数据包加密应该大家有遇到过：打开一个正经网站，网站底下蹦出个不正经广告——比如X通的流量浮层，X信的插入式广告……（我没有针对谁）但是这几年，我们会发现这种广告逐渐变少了，其原因就是大家都开始采用 HTTPS 了。被人插入这种广告的方法其实很好理解：你的网页数据包被抓取-&gt;在数据包到达你手机之前被篡改-&gt;你得到了带网页广告的数据包-&gt;渲染到你手机屏幕。而 HTTPS 进行了包加密，就解决了这个问题。严格来说我认为从手段上来看，它不算是一种前端加密场景；但是从解决问题的角度来看，这确实是前端需要知道的事情。 Plan全面采用 HTTPS 场景-展示成果加密经常有人开发网页爬虫爬取大家辛辛苦苦一点一点发布的数据成果，有些会影响你的竞争力，有些会降低你的知名度，甚至有些出于恶意爬取你的公开数据后进行全量公开……比如有些食谱网站被爬掉所有食谱，站点被克隆；有些求职网站被爬掉所有职位，被拿去卖信息；甚至有些小说漫画网站赖以生存的内容也很容易被爬取。 Plan将文本内容进行展示层加密，利用字体的引用特点，把拿给爬虫的数据变成“乱码”。举个栗子：正常来讲，当我们拥有一串数字“12345”并将其放在网站页面上的时候，其实网站页面上显示的并不是简单的数字，而是数字对应的字体的“12345”。这时我们打乱一下字体中图形和字码的对应关系，比如我们搞成这样： 图形：1 2 3 4 5字码：2 3 1 5 4 这时，如果你想让用户看到“12345”，你在页面中渲染的数字就应该是“23154”。这种手段也可以算作一种加密。具体的实现方法可以看一下《Web 端反爬虫技术方案》。 React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？写出如下代码的打印结果123456789function changeObjProperty(o) &#123; o.siteUrl = \"http://www.baidu.com\" o = new Object() o.siteUrl = \"http://www.google.com\"&#125; let webSite = new Object();changeObjProperty(webSite);console.log(webSite.siteUrl);// http://www.baidu.com 编程算法题1用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。 123456789101112function fn(num) &#123; let num1 = num / 10; let num2 = num % 10; if (num1 &lt; 1) &#123; return num; &#125; else &#123; num1 = Math.floor(num1); return `$&#123;num2&#125;$&#123;fn(num1)&#125;` &#125;&#125;var a = fn(123456);console.log(a, typeof a) 123456789101112131415161718192021function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3)&#125;Foo.a = function() &#123; console.log(4)&#125;Foo.a();let obj = new Foo();obj.a();Foo.a();// 4// 2// 1 12345678910111213141516171819202122232425262728293031323334353637function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行Foo.prototype.a = function() &#123; console.log(3)&#125;// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3Foo.a = function() &#123; console.log(4)&#125;// 现在在 Foo 上挂载了直接方法 a ，输出值为 4Foo.a();// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以// # 输出 4let obj = new Foo();/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。2. 在新对象上挂载直接方法 a ，输出值为 2。*/obj.a();// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，// # 输出 2Foo.a();// 构建方法里已经替换了全局 Foo 上的 a 方法，所以// # 输出 1 Async/Await 如何通过同步的方式实现异步Async/Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式 修改以下 print 函数，使之输出 0 到 99，或者 99 到 0要求： 只能修改 setTimeout 到 Math.floor(Math.random() * 1000 的代码 不能修改 Math.floor(Math.random() * 1000 不能使用全局变量12345678function print(n)&#123; setTimeout(() =&gt; &#123; console.log(n); &#125;, Math.floor(Math.random() * 1000));&#125;for(var i = 0; i &lt; 100; i++)&#123; print(i);&#125; 解法：12345678function print(n)&#123; setTimeout(() =&gt; &#123; console.log(n); &#125;,1, Math.floor(Math.random() * 1000));&#125;for(var i = 0; i &lt; 100; i++)&#123; print(i);&#125; 12345678910function print(n)&#123; setTimeout(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(n) &#125;, n * 1000) &#125;,Math.floor(Math.random() * 1000));&#125;for(var i = 0; i &lt; 100; i++)&#123; print(i);&#125; 123456789function print(n)&#123; setTimeout((function() &#123; console.log(n) return () =&gt; &#123;&#125; &#125;)(), Math.floor(Math.random() * 1000));&#125;for(var i = 0; i &lt; 100; i++)&#123; print(i);&#125; 不用加减乘除运算符，求整数的7倍1234function fn(m) &#123; let arr = new Array(m); return [...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr].length&#125; 考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素12345678910111213function fn(m, n) &#123; let arr = Array.from(&#123;length: m&#125;, (item, key) =&gt; key + 1) let result = new Set(); for (let i = 0; i &lt; n; i++) &#123; let luckDog = Math.floor(Math.random()*m); if (!result.has(arr[luckDog])) &#123; result.add(arr[luckDog]) &#125; else &#123; i--; &#125; &#125; return result;&#125; 由于随机从100K个数据中随机选取10k个数据，可采用统计学中随机采样点的选取进行随机选取，如在0-50之间生成五个随机数，然后依次将每个随机数进行加50进行取值，性能应该是最好的。 编程题，请写一个函数，完成以下功能输入： [1,2,3,5,7,8,10]输出：13,5,78,10如果连续数字的话，就取连续的第一个数和最后一个数，中间用~隔开。如果不连续就用，隔开。 1234567891011121314151617const nums1 = [1, 2, 3, 5, 7, 8, 10];function simplifyStr(num) &#123; var result = []; var temp = num[0] num.forEach((value, index) =&gt; &#123; if (value + 1 !== num[index + 1]) &#123; if (temp !== value) &#123; result.push(`$&#123;temp&#125;~$&#123;value&#125;`) &#125; else &#123; result.push(`$&#123;value&#125;`) &#125; temp = num[index + 1] &#125; &#125;) return result;&#125;console.log(simplifyStr(nums1).join(','))","tags":[{"name":"前端","slug":"前端","permalink":"https://userlvqingke.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"https://userlvqingke.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"微信小程序全介绍","date":"2020-06-18T12:31:43.000Z","path":"微信小程序全介绍/","text":"微信小程序和H5页H5和微信小程序在不同的场景下各有千秋，具体使用哪一种要具体分析，看中哪一方便的能力。 描述 H5 微信小程序 运行环境 浏览器、WebView 微信APP 系统权限 弱 强 直接分享朋友圈 能 不能 扫码识别 能 能 支付能力 多种 微信支付 流畅度 一般 好 入口数量 少 较多 专属入口 无 有 主动触达渠道 短信 微信 简易功能成本 低 低 系统功能成本 高 低 迭代周期 短 较长 外部链接 较少 多","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://userlvqingke.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"计算机网络简介","date":"2020-06-18T06:29:29.000Z","path":"计算机网络简介/","text":"TCP特性TCP提供一种面向连接的、可靠的字节流服务 三次握手 浏览器发包给服务器 服务器发包给浏览器，告诉浏览器我收到你的请求了 浏览器发包给服务器，告诉服务器我能收到你的包 四次挥手 浏览器：我没有包要传给服务器了，但还可以接受服务器传回的包 服务器：好的，那可以断开连接了，我准备下 服务器：准备好了，向浏览器发起断开连接的请求 浏览器：收到服务器发来的请求，发包确认收到 HTTP特性 HTTP协议构建于TCP/IP协议之上，是一个应用层协议，默认端口号：80 HTTP是无连接状态的 请求报文请求行、请求头、请求体 响应报文响应行、响应头、响应体 HTTPS特性HTTPS即HTTP over TLS，是一种在加密信道进行HTTP内容传输的协议 IP协议简介IP协议位于TCP/IP协议的第三层——网络层，与传输层协议相比，网络层的责任是提供点到点的服务，而传输层则是提供端到端的服务 Socket简介Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://userlvqingke.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://userlvqingke.github.io/tags/HTTPS/"},{"name":"TCP","slug":"TCP","permalink":"https://userlvqingke.github.io/tags/TCP/"}]},{"title":"WebView简介","date":"2020-06-18T03:14:35.000Z","path":"WebView简介/","text":"简介webview是一个基于webkit引擎、展示web页面的控件 作用 显示和渲染web页面 直接使用HTML文件做布局 可与JavaScript交互调用 WebView控件功能签到，除了具有一般View的属性和设置外，还可以对url请求、页面加载、渲染、页面交互进行强大的处理 使用介绍 WebView类自身的常见方法 WebView的最常用的工具类：WebSettings类、WebViewClient类、WebChromeClient类 Android 和 JS的交互WebView 与 js 交互","tags":[{"name":"WebView","slug":"WebView","permalink":"https://userlvqingke.github.io/tags/WebView/"}]},{"title":"javascript promise 全介绍","date":"2020-06-16T12:22:48.000Z","path":"javascript-promise-全介绍/","text":"promise ajax async/await 关系 promise是一个语法，用来处理异常行为，优化异步的语法 ajax，是JavaScript中一种技术名称，可以向服务器传送或获取资源，并且不需要重新渲染页面，大大减轻了服务器的压力和提高了用户的体验。 async/await， 是可以基于promise来处理异步语法结构，使之更适类似同步语言，易读。 Promise结构Promise 为构造函数，也是一个对象，从上图可以知道，Promise可以直接使用的有： 12345Promise.all()Promise.allSettled()Promise.race()Promise.resolve()Promise.reject() 通过new操作符创建的对象，可以使用Promise原型（prototype）中的方法/属性： 123456let p = new Promise((resolve, reject) =&gt; &#123;&#125;);p.then()p.catch()p.finally() Promise 状态Promise执行异步操作有着不同的进度状态： 123pending: Promise事件已在运行中，尚未取得结果fulfilled/resolved: Promise事件已执行完毕且操作成功，回传resolve结果rejected: Promise事件已执行完毕且操作失败，回传reject结果 判断Promise事件是否执行完毕，看Promise事件中的resolve/reject事件是否触发。如果两个都没有触发，则Promise事件停留在pending状态 12[[PromiseStatus]]: \"pending\" // 表示目前的进度状态[[PromiseValue]]: undefined // 表示resolve和reject的返回值 观察下面Promise事件的状态变化及回传值 建立自己的promise要熟悉Promise，最好的方式莫过于自己写一次PromisePromise创建实例对象时，需要传一个函数作为参数。此函数的参数有两个：resolve,reject,这两个方法表示成功的回传，失败的回传；特别注意，这两个回传只会执行其中之一，且只会执行一次，回传后代表Promise事件结束。 12345678910function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; let num = Math.random() &gt; 0.5 ? 1 : 0; if (num) &#123; resolve('success') &#125; else &#123; reject('fail') &#125; &#125;)&#125; 执行Promise事件，必定经过Pending状态。接下来进入Fulfilled或Rejected其中之一。并且可以使用then()或catch()取得成功或失败的结果。.then(onFulfilled, onRejected)中可以带两个回调函数，两个可以携带自己的参数onFulfilled: Promise事件执行成功时，所带入的参数是Promise函数中resolve回传值；onRejected: Promise事件执行失败是，所带入的参数是Promise函数中reject回传值； 123456promise().then((success) =&gt; &#123; console.log(success)&#125;, (fail) =&gt; &#123; console.log(fail)&#125;) 大部分情况下，开发者习惯用.then()来接受成功的回传值，用.catch()接受失败的回传值 1234567promise().then((success) =&gt; &#123; console.log(success)&#125;).catch((fail) =&gt; &#123; console.log(fail)&#125;) 链式调用为了确保异步完成后才执行另一种方法，过去都是通过callback的方式来实现。Promise的一个特点：then、catch都可以使用链接的方式不断的进行下一个任务举个列子： 1234567891011121314151617181920212223function promise(num) &#123; return new Promise((resolve, reject) =&gt; &#123; num ? resolve(`$&#123;num&#125; success`) : reject('fail') &#125;)&#125;promise(1).then(success =&gt; &#123; console.log(success); return promise(2)&#125;).then(success =&gt; &#123; console.log(success); return promise(0) // 这个阶段会进入catch&#125;).then(success =&gt; &#123; // 由于上个阶段处理的结果是reject，所以不会进入这里 console.log(success); return promise(3)&#125;).catch(fail =&gt; &#123; console.log(fail); return promise(3)&#125;) Then VS Catch的失败回传差异then和catch都可以使用链式调用，都可以处理reject回传值不适用then接受失败：无论哪个阶段遇到reject，都会直接跳到catch，在其后的then都不会执行。catch也可以返回promise对象，但开发中很少这么用。 1这种情况见上一段代码 使用咱接收失败：then中两个函数式必定接收其中一个（onFulfilled、onRejected）。 12345678910111213141516171819202122232425promise(0).then(success =&gt; &#123; console.log(success); return promise(1)&#125;, fail =&gt; &#123; console.log(fail); return promise(2)&#125;).then(success =&gt; &#123; console.log(success); return promise(0)&#125;, fail =&gt; &#123; console.log(fail); return promise(3)&#125;).then(success =&gt; &#123; console.log(success); return promise(4)&#125;, fail =&gt; &#123; console.log(fail); return promise(5)&#125;).then(success =&gt; &#123; console.log(success);&#125;) Promise Finally完成最后放可以接收finally来确认工作结束，finally不带任何参数。无论是成功或失败，都会走。 Promise 方法介绍Promise APIPromise.all(): 多个Promise同时并发执行，全部成功完成后统一返回。如有失败，则触发catch返回第一个失败的信息Promise.allSettled(): 多个Promise同时并发执行，全部完成后统一返回，无论成功/失败，结果都包含在返回的数组里。Promise.resolve(): 定义了Funfilled的Promise对象Promise.reject(): 定义了Rejected的Promise对象Promise.race(): 多个Promise同时并发执行，去第一个完成的结果返回。 Promise 按顺序执行异步事件 需要搞清楚的是Promise.all是并行执行Promise而不是顺序执行 一个promise在创建的时候就会执行，也就是说只要顺序创建，就是顺序执行12345678910111213141516方案一 function promise(index) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(index); &#125;)&#125;function executePromises(promises) &#123; let result = Promise.resolve('success'); promises.forEach(item =&gt; &#123; result = result.then(() =&gt; &#123; return promise(item); &#125;) &#125;)&#125;executePromises([1, 2, 3, 4]) 12345678910111213方案二 async/awaitfunction promise(index) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(index); &#125;)&#125;async function executePromises(promises) &#123; for (let i = 0, len = promises.length; i &lt; len; i++) &#123; await promise(promises[i]) &#125;&#125;executePromises([1,2,3,4]) 123456789101112131415方案三 递归方式function promise(index) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(index); &#125;)&#125;function executePromises(promises, index) &#123; if (index &gt;=0 &amp;&amp; index &lt; promises.length) &#123; promise(promises[index]) index++ executePromises(promises, index) &#125;&#125;executePromises([1,2,3,4], 0) 使用Promise 改写XMLHttpRequestPromise很多时候用来处理ajax请求传统实现方式中，用XMLHttpRequest构造实例对象，定义请求方法(GET)及状态(onload)，并发送请求，拿到结果后的其他行为在onload中处理12345678910111213141516let url = 'index.html';// 创建XMLHttpRequest实例对象let xhr = new XMLHttpRequest();// 定义方法xhr.open('GET', url);// 请求完成时，触发xhr.onload(() =&gt; &#123; if (xhr.status === 200) &#123; // 请求成功 console.log(xhr.response) &#125; else &#123; // 请求失败 &#125;&#125;)// 发送请求xhr.send() 来，我们用promise封装GET请求123456789101112131415161718192021function get(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload(() =&gt; &#123; if (xhr.status === 200) &#123; resolve(xhr.response); &#125; else &#123; reject(xhr.status); &#125; &#125;) xhr.send() &#125;)&#125;get('index.html').then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)","tags":[{"name":"javascript","slug":"javascript","permalink":"https://userlvqingke.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://userlvqingke.github.io/tags/promise/"},{"name":"异步","slug":"异步","permalink":"https://userlvqingke.github.io/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"javascript中理解发布-订阅模式","date":"2020-06-16T06:42:04.000Z","path":"javascript中理解发布-订阅模式/","text":"案例一描述：小红、小花在淘宝看上了同一款式的鞋，联系卖家才知道已经没有了。得一周后才有货，卖家让她们关注了卖家的淘宝店，待有货时通知到她们； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表，存放订阅者回调函数// 增加订阅者shoeObj.listen = function(key, fn) &#123; if (!shoeObj.list[key]) &#123; // 之前没有订阅过该消息，则给该消息创建一个缓存列表 shoeObj.list[key] = []; &#125; // 订阅消息添加到缓存列表中 shoeObj.list[key].push(fn)&#125;// 发布消息shoeObj.trigger = function() &#123; // 取出消息类型 let key = Array.prototype.shift.call(arguments); // 取出该消息对应的回调函数的集合 let fns = shoeObj.list[key]; // 如果没有订阅过该消息的话，直接返回 if (!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++];) &#123; fn.apply(this, arguments) // 发送消息时，附送的参数 &#125;&#125;// 取消订阅shoeObj.remove = function(key, fn) &#123; let fns = shoeObj.list[key]; // 如果key对应的消息没有订阅过的话，则返回 if (!fns) &#123; return false; &#125; // 如果没有传入具体的回调函数，表示要取消key对应消息的所有信息 if (!fn) &#123; fns.length = 0; &#125; else &#123; // 删除指定的订阅回调函数 for(let i = fns.length -1; i &gt;= 0; i--) &#123; let _fn = fns[i]; console.log(_fn === fn, 'boolean') if (fn === _fn) &#123; fns.splice(i, 1); &#125; &#125; &#125;&#125;// 小红订阅消息shoeObj.listen('red', fn1 = function(size) &#123; console.log(`颜色：红色`); console.log(`尺码：$&#123;size&#125;`);&#125;)// 小花订阅消息shoeObj.listen('white', fn2 = function(size) &#123; console.log(`再一次颜色 白色`); console.log(`再一次尺码 $&#123;size&#125;`);&#125;)shoeObj.remove('red', fn1)shoeObj.trigger('red', '39');shoeObj.trigger('white', '40'); 案例二描述：案例一得另一种实现方式，使用ES6特性； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class ShoeObj &#123; constructor() &#123; // 缓存列表 this.list = []; &#125; // 创建订阅者 listener(key, fn) &#123; // 之前没有订阅过该消息的话，则创建一个缓存列表 if (!this.list[key]) &#123; this.list[key] = []; &#125; // 将订阅者的回调函数加入到缓存列表中 this.list[key].push(fn); &#125; // 发布消息 trigger() &#123; // 取出消息类型 let key = Array.prototype.shift.call(arguments); // 取出该消息对应的回调函数集合 let fns = this.list[key]; for(let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125; // 删除某订阅者订阅的消息 remove(key, fn) &#123; let fns = this.list[key]; // 如果该订阅消息不存在，则返回 if (!fns) &#123; return false; &#125; // 如果没有传入具体的回调函数，表示要取消key对应消息的所有信息 if (!fn) &#123; fns.length = 0; &#125; else &#123; // 删除指定的订阅回调函数 for(let i = fns.length - 1; i &gt;= 0; i--) &#123; let _fn = fns[i]; if (fn === _fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;&#125;let shoeObj = new ShoeObj();// 小红订阅消息shoeObj.listener('red', fn1 = function(size) &#123; console.log(`red-$&#123;size&#125;-xg`)&#125;)// 小花订阅消息shoeObj.listener('white', fn2 = function(size) &#123; console.log(`white-$&#123;size&#125;-xh`)&#125;)shoeObj.remove('red', fn1)shoeObj.trigger('red', '39')shoeObj.trigger('white', '40') 案例三描述：请实现一个 EventEmitter，包括 on、emit、remove 这三个操作。（Vue中组件间通信方式原理） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class EventEmitter &#123; constructor() &#123; this.list = []; // 缓存列表 &#125; // 创建订阅者 on(key, fn) &#123; // 如果当前订阅消息不存在，则创建新的缓存列表 if (!this.list[key]) &#123; this.list[key] = []; &#125; // 将订阅者的回调函数加入到缓存列表中 this.list[key].push(fn) &#125; // 发布消息 emit() &#123; // 取出消息类型 let key = Array.prototype.shift.call(arguments); // 取出消息类型的回调函数集合 let fns = this.list[key]; for(let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125; remove(key, fn) &#123; let fns = this.list[key]; // 当前消息不存在，则返回 if (!fns) &#123; return false; &#125; // 回调函数不存在，则清除整个消息对应的回调函数缓存列表 if (!fn) &#123; fns.length = 0; &#125; else &#123; for(let i = fns.length - 1; i &gt;= 0; i--) &#123; let _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;&#125;let obj = new EventEmitter();obj.on('click', function(name) &#123;console.log(`$&#123;name&#125;点击的`)&#125;)obj.emit('click', '小刚')","tags":[{"name":"javascript","slug":"javascript","permalink":"https://userlvqingke.github.io/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://userlvqingke.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://userlvqingke.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","permalink":"https://userlvqingke.github.io/tags/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"webpack操作总结","date":"2020-06-14T10:52:52.000Z","path":"webpack操作总结/","text":"基础篇 环境搭建 1234567891011安装nvm:curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash安装nodejs 和 npmnvm install v12.13.0创建空目录和package.jsonmkdir my-projectcd my-project/npm init -y安装webpack和webpack-clinpm i webpack webpack-cli --save-dev执行 ./node_modules/.bin/webpack -v 查看安装的webpack版本 简单运行demo 12345678910111213创建webpack.config.jsconst path = require('path');module.exports = &#123; mode: 'production', entry: path.join(__dirname, './src/index.js'), output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;运行：./node_modules/.bin/webpack默认执行webpack.config.js配置文件 通过npm script 运行webpack 123456脚本呀package.json能读取到node_modules/.bin/目录下的文件：scripts: &#123; \"build\": webpack&#125;即可 entry 打包入口文件 1234567单入口文件：entry: path.join(__dirname, 'src/index') // 字符串多入口文件：entry: &#123; index: path.join(__dirname, 'src/index.js'), main: path.join(__dirname, 'src/main.js')&#125; // 对象 output 打包输出文件 123456output告诉webpack如何将编译后的文件输出到磁盘output: &#123; path: path.join(__dirname, 'dist'), filename: [name].js&#125;[name] 占位符，确保文件名称统一，适用于多入口构建 loaders 12345678webpack 开箱即用只支持js和json两种文件类型，通过loaders去支持将其他文件类型转为有效模块，并加入到依赖图中loaders本身是函数，接受参数，返回转换结果module: &#123; rules: [&#123; test: /\\.css$/, // test指定匹配规则 use: 'css-loader' // use指定使用的loader名称 &#125;]&#125; 名称 描述 babel-loader 转换ES6及以后的新特性语法 css-loader 支持.css文件的加载和解析 less-loader 将less文件转换为css ts-loader 将TS转为JS file-loader 对图片、字体等的打包 raw-loader 将文件以json形式导入 thread-loader 多进程打包js和css plugins 123456增强loader的功能，作用于整个构建过程plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ] // 所有的plugins 放到数组里 名称 描述 CommonsChunkPlugin 将chunks相同的模块代码提取为公共js CleanWebpackPlugin 清理构建目录 ExtractTextWebpackPlugin 将css从bundle文件里提取一个单独的css文件 CopyWebpackPlugin 将文件或文件夹拷贝到输出目录 HtmlWebpackPlugin 创建html文件，承载输出的bundle UglifyjsWebpackPlugin 压缩JS ZipWebpackPlugin 将打包出的资源生成一个zip包 mode 12mode指定当前的构建环境：production、development、none默认为production mode内置函数的功能 选项 描述 development 设置process.env.NODE_ENV的值为development，开启NamedChunksPlugin 和 NamedModulesPlugin production 设置process.env.NODE_ENV的值为production，开启… none 不开启任何优化项 解析ES6 123456789101112131415安装依赖npm i babel-loader @babel/core @babel/preset-env --save-dev创建.babelrc文件，内容：&#123; \"presets\": [ \"@babel/preset-env\" ]&#125;webpack.config.js中：module: &#123; rules: [&#123; test: /\\.js$/, use: 'babel-loader' &#125;]&#125; 解析css 12345678910css-loader 用于加载css文件，并且转换成commonjs对象，插入到js中style-loader 将样式通过style标签，插入到head中安装依赖 npm i style-loader css-loader --save-devwebpack.config.js中：module: &#123; rules: [&#123; test: /\\.css/, use: ['style-loader', 'css-loader'] &#125;]&#125; 解析less 、sass 123456789less-loader 将less转为css安装依赖 npm i less less-loader --save-devwebpack.config.js中：module: &#123; rules: [&#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;]&#125; 解析图片、字体 1234567891011安装依赖 npm i file-loader --save-devwebpack.config.js中module: &#123; rules: [&#123; test: /\\.(png|jpg|gif|jpeg)$/, use: 'file-loader' &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: 'file-loader' &#125;]&#125; 1234567891011121314还可以使用use-loader解析图片、字体，设置小资源自动base64安装依赖 npm i url-loader --save-devwebpack.config.js 中：module: &#123; rules: [&#123; test: /\\.(png|jpg|gif|jpeg)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 10240 &#125; &#125;] &#125;]&#125; webpack文件监听 123456789101112131415161718文件监听是在发现源码发生变化时，自动重新构建输出新的构建文件。webpack开启文件监听到两种方式：scripts: &#123; build: webpack --watch&#125;在配置文件webpack.config.js中添加watch: true原理：轮询判断文件最后编译时间是否发生变化某个文件发生变化，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeoutwebpack.config.js中：module.exports = &#123; watch: true, // 默认false，不开启监听 watchOptions: &#123; ignore: /node_modules/, // 默认为空，不监听的文件或文件夹，支持正则 aggreateTimeout: 300, // 监听变化发生后300ms再去执行，默认300ms poll: 1000 // 判断文件是否发生变化，是通过不停询问系统指定文件是否发生变化，默认每秒1000次 &#125;&#125; webpack热更新 12345678910111213141516使用webpack-dev-server不刷新浏览器、不输出编译文件，而是放在内存里webpack.config.js中：module.exports = &#123; mode: 'development', devServer: &#123; contentBase: path.join(__dirname, 'dist'), hot: true &#125;&#125;package.json中：&#123; scripts: &#123; server: webpack-dev-server --open &#125;&#125; 123456789101112131415161718使用webpack-dev-middlewarewdm将webpack输出的文件传给服务端直接上代码：const express = require('express');const webpack = require('webpack');const WebpackDevMiddleware = require('webpack-dev-middleware');const app = express();const config = require('./webpack.config.dev.js');const compiler = webpack(config);app.use(WebpackDevMiddleware(compiler, &#123; publicPath: config.output.path&#125;))app.listen(3000, function() &#123; console.log('listen 3000');&#125;) 原理： 12345webpack compiler 编译生成bundle.jsHMR Server 将热更新的文件传给 HMR RuntimeBundle Server 提供文件浏览器访问HMR Runtime 注入到浏览器的bundle.js中，跟新文件变化bundle.js 构建输出的文件 此处缺少一张图 位置：/Users/aaa/Downloads/youdao-note-imgs 文件指纹 1234如何生成：Hash: 和整个项目的构建有关，只有项目文件修改，整个项目构建的hash值就会更改Chunkhash: 和webpack打包的chunk有关，不同的entry会生成不同的chunkhash值Contenthash: 根据文件内容来定义hash，文件内容不变，则Contenthash不变 1234567js文件指纹设置webpack.config.js中：mode: 'production',output: &#123; path: path.join(__dirname, 'dist'), filename: [name]_[chunkhash:8].js&#125; 1234567891011121314151617css文件指纹设置：安装依赖插件：npm i mini-css-extract-plugin --save-devwebpack.config.js中const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] &#125;] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;) ]&#125; 123456789101112131415161718192021图片、字体文件指纹设置：webpack.config.js中：module: &#123; rules: [&#123; test: /\\.png|jpg|gif|jpeg$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name]_[hash:8].[ext]' &#125; &#125; &#125;, &#123; test: /\\.woff|woff2|eot|ttf|otf$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name]_[hash:8].[ext]' &#125; &#125; &#125;]&#125; 占位符 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件相对路径 [folder] 文件所在的文件夹 [contenthash] 文件的内容hash，默认由md5生成 [hash] 文件内容的hash，默认由md5生成 [emoji] 一个随机的指代文件内容的emoji js html css 文件压缩 12js压缩webpack4 内置了uglifyjs-webpack-plugin, mode为production时，自动执行压缩操作 1234567891011121314151617181920212223html压缩安装依赖插件：npm i html-webpack-plugin --save-devwebpack.config.js中：const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, 'src/index.html'), filename: 'index.html', chunks: [index], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCss: true, minifyJs: true, removeComments: false &#125; &#125;) ]&#125; 12345678910111213141516css压缩安装依赖 npm i optimize-css-assets-webpack-plugin cssnano --save-devwebpack.config.js中：const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');module.exports = &#123; plugins: [ new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano'), cssProcessorPluginOptions: &#123; preset: ['default', &#123; discardComments: &#123; removeAll: true &#125; &#125;] &#125;, canPrint: true &#125;) ]&#125; 进阶篇 自动清理构建目录产物 1234通过package.json中的scripts清理scripts: &#123; build: rm -rf ./dist &amp;&amp; webpack&#125; 123456789通过插件 clean-webpack-plugin安装依赖： npm i clean-webpack-plugin --save-devwebpack.config.js中：const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; plugins: [ new CleanWebpackPlugin() ]&#125; 自动补齐css3前缀 1234567891011121314151617181920212223安装依赖 npm i postcss-loader autoprefixer --save-devwebpack.config.js中module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use ['style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; [require('autoprefixer')] &#125; &#125;] &#125;] &#125;&#125;package.json中&#123; \"browserslist\": [ \"last 2 version\", \"&gt;1%\", \"ios 7\" ]&#125; px自动转为css 1234567891011121314151617181920212223242526通过使用px2rem-loader、lib-flexiblepx2rem-loader: 将px转为remlib-flexible: 时时计算根元素字体大小安装依赖 npm i px2rem-loader --save-devnpm i lib-flexible --savewebpack.config.js中module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use ['style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; [require('autoprefixer')] &#125; &#125;, &#123; loader: 'px2rem-loader', options: &#123; remUni: 75, remPricision: 8 &#125; &#125;] &#125;] &#125;&#125; 静态资源内联 123456依赖于raw-loader意义：代码层面：页面框架到初始化脚本；上报相关打点；css内联避免页面闪动请求层面：减少HTTP网络请求小图片或者字体内联，用url-loader raw-loader 没有使用成功5. 多页面应用编译 12345通用方案：动态获取entry和设置 html-webpack-plugin数量依赖于 glob 安装依赖 npm i glob --save-dev具体遍历封装参考 https://github.com/userlvqingke/testEmpty webpack.pro.js soucemap应用 123456webpack.config.js中module.exports = &#123; module: &#123; devtool: 'souce-map' // 值有很多，相见webpack开发文档 &#125;&#125; 提取页面公共资源 1234基础库分离思路：将react、react-dom基础包通过cdn引入，不打入bundle.js中使用 html-webpack-externals-plugin 123456789101112131415161718webpack3中用到 CommonsChunkPluginwebpack4中用到 SplitChunksPluginwebpack.config.js中module.exports = &#123; optimization: &#123; splitChunks: &#123; minSize: 0 // 公共模块最小大小 cacheGroups: &#123; commons: &#123; name: 'commons', chunks: 'all', minChunks: 2 // 几处共用到 &#125; &#125; &#125; &#125;&#125; tree shaking(摇树优化) 1234概念：1个模块可能有很多方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle里面去，tree shaking就是只把用到的方法打入bundle中，没有用到的方法会在uglify阶段被删除掉使用：webpack默认支持，在.babelrc中设置modules: false即可 mode: production 默认开启要求必须是ES6语法 scope hoisting 原理 123456现象：构建后代码存在大量闭包代码问题：大量函数闭包包裹代码，导致体积增大（模块越多越明显）运行代码时，创建的函数作用域变多，内存开销变大原理：将所有模块的代码按照引入顺序放在一个函数作用域，然后适当命名一些变量以防止变量名冲突对比：通过scope hoisting可以减少函数声明代码和内存开销 代码分割和动态import 12345678910懒加载js脚本的方式：CommonJS: require.ensureES6:动态import（目前原生还没有支持，需要babel转换）安装依赖插件：npm i @babel/plugin-syntax-dynamic-import --save-dev.babelrc中：&#123; plugins: [\"plugin-syntax-dynamic-import\"]&#125; 在webpack中使用eslint 12345678910111213141516171819202122232425262728293031323334353637安装依赖:npm i eslint-loader --save-devwebpack.config.js中：module.exports = &#123; module: &#123; rules: [&#123; test: /\\.js$/, use: 'eslint-loader' &#125;] &#125;&#125;创建.eslint文件\"use strict\";module.exports = &#123; root: true, env: &#123; node: true, es6: true &#125;, parserOptions: &#123; ecmaVersion: 2018, sourceType: 'module' &#125;, globals: &#123; Atomics: 'readonly', SharedArrayBuffer: 'readonly' &#125;, rules: &#123; indent: ['error', 4], semi: ['off', \"always\"], \"multiline-comment-style\": ['off', \"always\"] &#125;, extends: [ 'standard' ],&#125; 1234制定团队的ESLint规范不重复造轮子，基于eslint:recommend进行改进能够帮助发现代码错误的规则，全部开启帮助团队保持代码风格的统一，而不是限制开发体验 webpack打包组件和基础库 1参考 https://github.com/userlvqingke/-jacklv-js-demo webpack 实现ssr打包 123456这个现在不做具体尝试渲染：HTML + CSS + JS + Data --&gt;渲染后的html服务端： 所有模版资源都存储在服务端 内网机器拉取数据更快 一个html返回所有数据 *** 客户端渲染 服务端渲染 请求 多个请求（html和数据等） 1个请求 加载过程 html和数据串行加载 1个请求返回Html和数据 渲染 前端渲染 服务端渲染 可交互 图片等静态资源加载完毕，JS逻辑执行完成可交互 14.优化构建时命令行的显示日志 12345678910安装依赖插件：friendly-errors-webpack-pluginnpm i friendly-errors-webpack-plugin --save-devwebpack.config.js中const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin')module.exports = &#123; plugins: [ new FriendlyErrorsWebpackPlugin() ] stats: 'errors-only'&#125; 构建异常和中断处理 12345构建完成后，输入echo $?获取错误码webpack4之前的版本构建失败不会抛出错误码（error code）Nodejs 中process.exit规范 0标识成功，回调函数中err为null 非0标识失败，回调函数中err不为null，err.code 是要传给exit的值 1234567891011121314151617181920212223242526webpack.config.js中 webpack4module.exports = &#123; plugins: [ function() &#123; this.hook.done.tap('done', stats =&gt; &#123; if (stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf('--watch') == -1) &#123; console.log('build error') process.exit(1) &#125; &#125;) &#125; ]&#125;webpack.config.js中 webpack3module.exports = &#123; plugins: [ function() &#123; this.plugin('done', stats =&gt; &#123; if (stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf('--watch') == -1) &#123; console.log('build error') process.exit(1) &#125; &#125;) &#125; ]&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://userlvqingke.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://userlvqingke.github.io/tags/webpack/"},{"name":"构建工具","slug":"构建工具","permalink":"https://userlvqingke.github.io/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo 操作指南","date":"2020-06-11T10:52:52.000Z","path":"hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"博客","slug":"博客","permalink":"https://userlvqingke.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"https://userlvqingke.github.io/tags/hexo/"}]}]