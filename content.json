[{"title":"javascript promise 全介绍","date":"2020-06-16T12:22:48.000Z","path":"javascript-promise-全介绍/","text":"promise ajax async/await 关系 promise是一个语法，用来处理异常行为，优化异步的语法 ajax，是JavaScript中一种技术名称，可以向服务器传送或获取资源，并且不需要重新渲染页面，大大减轻了服务器的压力和提高了用户的体验。 async/await， 是可以基于promise来处理异步语法结构，使之更适类似同步语言，易读。 Promise结构Promise 为构造函数，也是一个对象，从上图可以知道，Promise可以直接使用的有： 12345Promise.all()Promise.allSettled()Promise.race()Promise.resolve()Promise.reject() 通过new操作符创建的对象，可以使用Promise原型（prototype）中的方法/属性： 123456let p = new Promise((resolve, reject) =&gt; &#123;&#125;);p.then()p.catch()p.finally() Promise 状态Promise执行异步操作有着不同的进度状态： 123pending: Promise事件已在运行中，尚未取得结果fulfilled/resolved: Promise事件已执行完毕且操作成功，回传resolve结果rejected: Promise事件已执行完毕且操作失败，回传reject结果 判断Promise事件是否执行完毕，看Promise事件中的resolve/reject事件是否触发。如果两个都没有触发，则Promise事件停留在pending状态 12[[PromiseStatus]]: \"pending\" // 表示目前的进度状态[[PromiseValue]]: undefined // 表示resolve和reject的返回值 观察下面Promise事件的状态变化及回传值 建立自己的promise要熟悉Promise，最好的方式莫过于自己写一次PromisePromise创建实例对象时，需要传一个函数作为参数。此函数的参数有两个：resolve,reject,这两个方法表示成功的回传，失败的回传；特别注意，这两个回传只会执行其中之一，且只会执行一次，回传后代表Promise事件结束。 12345678910function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; let num = Math.random() &gt; 0.5 ? 1 : 0; if (num) &#123; resolve('success') &#125; else &#123; reject('fail') &#125; &#125;)&#125; 执行Promise事件，必定经过Pending状态。接下来进入Fulfilled或Rejected其中之一。并且可以使用then()或catch()取得成功或失败的结果。.then(onFulfilled, onRejected)中可以带两个回调函数，两个可以携带自己的参数onFulfilled: Promise事件执行成功时，所带入的参数是Promise函数中resolve回传值；onRejected: Promise事件执行失败是，所带入的参数是Promise函数中reject回传值； 123456promise().then((success) =&gt; &#123; console.log(success)&#125;, (fail) =&gt; &#123; console.log(fail)&#125;) 大部分情况下，开发者习惯用.then()来接受成功的回传值，用.catch()接受失败的回传值 1234567promise().then((success) =&gt; &#123; console.log(success)&#125;).catch((fail) =&gt; &#123; console.log(fail)&#125;) 链式调用为了确保异步完成后才执行另一种方法，过去都是通过callback的方式来实现。Promise的一个特点：then、catch都可以使用链接的方式不断的进行下一个任务举个列子： 1234567891011121314151617181920212223function promise(num) &#123; return new Promise((resolve, reject) =&gt; &#123; num ? resolve(`$&#123;num&#125; success`) : reject('fail') &#125;)&#125;promise(1).then(success =&gt; &#123; console.log(success); return promise(2)&#125;).then(success =&gt; &#123; console.log(success); return promise(0) // 这个阶段会进入catch&#125;).then(success =&gt; &#123; // 由于上个阶段处理的结果是reject，所以不会进入这里 console.log(success); return promise(3)&#125;).catch(fail =&gt; &#123; console.log(fail); return promise(3)&#125;) Then VS Catch的失败回传差异then和catch都可以使用链式调用，都可以处理reject回传值不适用then接受失败：无论哪个阶段遇到reject，都会直接跳到catch，在其后的then都不会执行。catch也可以返回promise对象，但开发中很少这么用。 1这种情况见上一段代码 使用咱接收失败：then中两个函数式必定接收其中一个（onFulfilled、onRejected）。 12345678910111213141516171819202122232425promise(0).then(success =&gt; &#123; console.log(success); return promise(1)&#125;, fail =&gt; &#123; console.log(fail); return promise(2)&#125;).then(success =&gt; &#123; console.log(success); return promise(0)&#125;, fail =&gt; &#123; console.log(fail); return promise(3)&#125;).then(success =&gt; &#123; console.log(success); return promise(4)&#125;, fail =&gt; &#123; console.log(fail); return promise(5)&#125;).then(success =&gt; &#123; console.log(success);&#125;) Promise Finally完成最后放可以接收finally来确认工作结束，finally不带任何参数。无论是成功或失败，都会走。 Promise 方法介绍Promise APIPromise.all(): 多个Promise同时并发执行，全部成功完成后统一返回。如有失败，则触发catch返回第一个失败的信息Promise.allSettled(): 多个Promise同时并发执行，全部完成后统一返回，无论成功/失败，结果都包含在返回的数组里。Promise.resolve(): 定义了Funfilled的Promise对象Promise.reject(): 定义了Rejected的Promise对象Promise.race(): 多个Promise同时并发执行，去第一个完成的结果返回。 Promise 按顺序执行异步事件 需要搞清楚的是Promise.all是并行执行Promise而不是顺序执行 一个promise在创建的时候就会执行，也就是说只要顺序创建，就是顺序执行12345678910111213141516方案一 function promise(index) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(index); &#125;)&#125;function executePromises(promises) &#123; let result = Promise.resolve('success'); promises.forEach(item =&gt; &#123; result = result.then(() =&gt; &#123; return promise(item); &#125;) &#125;)&#125;executePromises([1, 2, 3, 4]) 12345678910111213方案二 async/awaitfunction promise(index) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(index); &#125;)&#125;async function executePromises(promises) &#123; for (let i = 0, len = promises.length; i &lt; len; i++) &#123; await promise(promises[i]) &#125;&#125;executePromises([1,2,3,4]) 123456789101112131415方案三 递归方式function promise(index) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(); console.log(index); &#125;)&#125;function executePromises(promises, index) &#123; if (index &gt;=0 &amp;&amp; index &lt; promises.length) &#123; promise(promises[index]) index++ executePromises(promises, index) &#125;&#125;executePromises([1,2,3,4], 0) 使用Promise 改写XMLHttpRequestPromise很多时候用来处理ajax请求传统实现方式中，用XMLHttpRequest构造实例对象，定义请求方法(GET)及状态(onload)，并发送请求，拿到结果后的其他行为在onload中处理12345678910111213141516let url = 'index.html';// 创建XMLHttpRequest实例对象let xhr = new XMLHttpRequest();// 定义方法xhr.open('GET', url);// 请求完成时，触发xhr.onload(() =&gt; &#123; if (xhr.status === 200) &#123; // 请求成功 console.log(xhr.response) &#125; else &#123; // 请求失败 &#125;&#125;)// 发送请求xhr.send() 来，我们用promise封装GET请求123456789101112131415161718192021function get(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload(() =&gt; &#123; if (xhr.status === 200) &#123; resolve(xhr.response); &#125; else &#123; reject(xhr.status); &#125; &#125;) xhr.send() &#125;)&#125;get('index.html').then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)","tags":[{"name":"javascript","slug":"javascript","permalink":"https://userlvqingke.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://userlvqingke.github.io/tags/promise/"},{"name":"异步","slug":"异步","permalink":"https://userlvqingke.github.io/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"javascript中理解发布-订阅模式","date":"2020-06-16T06:42:04.000Z","path":"javascript中理解发布-订阅模式/","text":"案例一描述：小红、小花在淘宝看上了同一款式的鞋，联系卖家才知道已经没有了。得一周后才有货，卖家让她们关注了卖家的淘宝店，待有货时通知到她们； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表，存放订阅者回调函数// 增加订阅者shoeObj.listen = function(key, fn) &#123; if (!shoeObj.list[key]) &#123; // 之前没有订阅过该消息，则给该消息创建一个缓存列表 shoeObj.list[key] = []; &#125; // 订阅消息添加到缓存列表中 shoeObj.list[key].push(fn)&#125;// 发布消息shoeObj.trigger = function() &#123; // 取出消息类型 let key = Array.prototype.shift.call(arguments); // 取出该消息对应的回调函数的集合 let fns = shoeObj.list[key]; // 如果没有订阅过该消息的话，直接返回 if (!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++];) &#123; fn.apply(this, arguments) // 发送消息时，附送的参数 &#125;&#125;// 取消订阅shoeObj.remove = function(key, fn) &#123; let fns = shoeObj.list[key]; // 如果key对应的消息没有订阅过的话，则返回 if (!fns) &#123; return false; &#125; // 如果没有传入具体的回调函数，表示要取消key对应消息的所有信息 if (!fn) &#123; fns.length = 0; &#125; else &#123; // 删除指定的订阅回调函数 for(let i = fns.length -1; i &gt;= 0; i--) &#123; let _fn = fns[i]; console.log(_fn === fn, 'boolean') if (fn === _fn) &#123; fns.splice(i, 1); &#125; &#125; &#125;&#125;// 小红订阅消息shoeObj.listen('red', fn1 = function(size) &#123; console.log(`颜色：红色`); console.log(`尺码：$&#123;size&#125;`);&#125;)// 小花订阅消息shoeObj.listen('white', fn2 = function(size) &#123; console.log(`再一次颜色 白色`); console.log(`再一次尺码 $&#123;size&#125;`);&#125;)shoeObj.remove('red', fn1)shoeObj.trigger('red', '39');shoeObj.trigger('white', '40'); 案例二描述：案例一得另一种实现方式，使用ES6特性； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class ShoeObj &#123; constructor() &#123; // 缓存列表 this.list = []; &#125; // 创建订阅者 listener(key, fn) &#123; // 之前没有订阅过该消息的话，则创建一个缓存列表 if (!this.list[key]) &#123; this.list[key] = []; &#125; // 将订阅者的回调函数加入到缓存列表中 this.list[key].push(fn); &#125; // 发布消息 trigger() &#123; // 取出消息类型 let key = Array.prototype.shift.call(arguments); // 取出该消息对应的回调函数集合 let fns = this.list[key]; for(let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125; // 删除某订阅者订阅的消息 remove(key, fn) &#123; let fns = this.list[key]; // 如果该订阅消息不存在，则返回 if (!fns) &#123; return false; &#125; // 如果没有传入具体的回调函数，表示要取消key对应消息的所有信息 if (!fn) &#123; fns.length = 0; &#125; else &#123; // 删除指定的订阅回调函数 for(let i = fns.length - 1; i &gt;= 0; i--) &#123; let _fn = fns[i]; if (fn === _fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;&#125;let shoeObj = new ShoeObj();// 小红订阅消息shoeObj.listener('red', fn1 = function(size) &#123; console.log(`red-$&#123;size&#125;-xg`)&#125;)// 小花订阅消息shoeObj.listener('white', fn2 = function(size) &#123; console.log(`white-$&#123;size&#125;-xh`)&#125;)shoeObj.remove('red', fn1)shoeObj.trigger('red', '39')shoeObj.trigger('white', '40') 案例三描述：请实现一个 EventEmitter，包括 on、emit、remove 这三个操作。（Vue中组件间通信方式原理） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class EventEmitter &#123; constructor() &#123; this.list = []; // 缓存列表 &#125; // 创建订阅者 on(key, fn) &#123; // 如果当前订阅消息不存在，则创建新的缓存列表 if (!this.list[key]) &#123; this.list[key] = []; &#125; // 将订阅者的回调函数加入到缓存列表中 this.list[key].push(fn) &#125; // 发布消息 emit() &#123; // 取出消息类型 let key = Array.prototype.shift.call(arguments); // 取出消息类型的回调函数集合 let fns = this.list[key]; for(let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125; remove(key, fn) &#123; let fns = this.list[key]; // 当前消息不存在，则返回 if (!fns) &#123; return false; &#125; // 回调函数不存在，则清除整个消息对应的回调函数缓存列表 if (!fn) &#123; fns.length = 0; &#125; else &#123; for(let i = fns.length - 1; i &gt;= 0; i--) &#123; let _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); &#125; &#125; &#125; &#125;&#125;let obj = new EventEmitter();obj.on('click', function(name) &#123;console.log(`$&#123;name&#125;点击的`)&#125;)obj.emit('click', '小刚')","tags":[{"name":"javascript","slug":"javascript","permalink":"https://userlvqingke.github.io/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://userlvqingke.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://userlvqingke.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","permalink":"https://userlvqingke.github.io/tags/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"webpack操作总结","date":"2020-06-14T10:52:52.000Z","path":"webpack操作总结/","text":"基础篇 环境搭建 1234567891011安装nvm:curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash安装nodejs 和 npmnvm install v12.13.0创建空目录和package.jsonmkdir my-projectcd my-project/npm init -y安装webpack和webpack-clinpm i webpack webpack-cli --save-dev执行 ./node_modules/.bin/webpack -v 查看安装的webpack版本 简单运行demo 12345678910111213创建webpack.config.jsconst path = require('path');module.exports = &#123; mode: 'production', entry: path.join(__dirname, './src/index.js'), output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;运行：./node_modules/.bin/webpack默认执行webpack.config.js配置文件 通过npm script 运行webpack 123456脚本呀package.json能读取到node_modules/.bin/目录下的文件：scripts: &#123; \"build\": webpack&#125;即可 entry 打包入口文件 1234567单入口文件：entry: path.join(__dirname, 'src/index') // 字符串多入口文件：entry: &#123; index: path.join(__dirname, 'src/index.js'), main: path.join(__dirname, 'src/main.js')&#125; // 对象 output 打包输出文件 123456output告诉webpack如何将编译后的文件输出到磁盘output: &#123; path: path.join(__dirname, 'dist'), filename: [name].js&#125;[name] 占位符，确保文件名称统一，适用于多入口构建 loaders 12345678webpack 开箱即用只支持js和json两种文件类型，通过loaders去支持将其他文件类型转为有效模块，并加入到依赖图中loaders本身是函数，接受参数，返回转换结果module: &#123; rules: [&#123; test: /\\.css$/, // test指定匹配规则 use: 'css-loader' // use指定使用的loader名称 &#125;]&#125; 名称 描述 babel-loader 转换ES6及以后的新特性语法 css-loader 支持.css文件的加载和解析 less-loader 将less文件转换为css ts-loader 将TS转为JS file-loader 对图片、字体等的打包 raw-loader 将文件以json形式导入 thread-loader 多进程打包js和css plugins 123456增强loader的功能，作用于整个构建过程plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ] // 所有的plugins 放到数组里 名称 描述 CommonsChunkPlugin 将chunks相同的模块代码提取为公共js CleanWebpackPlugin 清理构建目录 ExtractTextWebpackPlugin 将css从bundle文件里提取一个单独的css文件 CopyWebpackPlugin 将文件或文件夹拷贝到输出目录 HtmlWebpackPlugin 创建html文件，承载输出的bundle UglifyjsWebpackPlugin 压缩JS ZipWebpackPlugin 将打包出的资源生成一个zip包 mode 12mode指定当前的构建环境：production、development、none默认为production mode内置函数的功能 选项 描述 development 设置process.env.NODE_ENV的值为development，开启NamedChunksPlugin 和 NamedModulesPlugin production 设置process.env.NODE_ENV的值为production，开启… none 不开启任何优化项 解析ES6 123456789101112131415安装依赖npm i babel-loader @babel/core @babel/preset-env --save-dev创建.babelrc文件，内容：&#123; \"presets\": [ \"@babel/preset-env\" ]&#125;webpack.config.js中：module: &#123; rules: [&#123; test: /\\.js$/, use: 'babel-loader' &#125;]&#125; 解析css 12345678910css-loader 用于加载css文件，并且转换成commonjs对象，插入到js中style-loader 将样式通过style标签，插入到head中安装依赖 npm i style-loader css-loader --save-devwebpack.config.js中：module: &#123; rules: [&#123; test: /\\.css/, use: ['style-loader', 'css-loader'] &#125;]&#125; 解析less 、sass 123456789less-loader 将less转为css安装依赖 npm i less less-loader --save-devwebpack.config.js中：module: &#123; rules: [&#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;]&#125; 解析图片、字体 1234567891011安装依赖 npm i file-loader --save-devwebpack.config.js中module: &#123; rules: [&#123; test: /\\.(png|jpg|gif|jpeg)$/, use: 'file-loader' &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: 'file-loader' &#125;]&#125; 1234567891011121314还可以使用use-loader解析图片、字体，设置小资源自动base64安装依赖 npm i url-loader --save-devwebpack.config.js 中：module: &#123; rules: [&#123; test: /\\.(png|jpg|gif|jpeg)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 10240 &#125; &#125;] &#125;]&#125; webpack文件监听 123456789101112131415161718文件监听是在发现源码发生变化时，自动重新构建输出新的构建文件。webpack开启文件监听到两种方式：scripts: &#123; build: webpack --watch&#125;在配置文件webpack.config.js中添加watch: true原理：轮询判断文件最后编译时间是否发生变化某个文件发生变化，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeoutwebpack.config.js中：module.exports = &#123; watch: true, // 默认false，不开启监听 watchOptions: &#123; ignore: /node_modules/, // 默认为空，不监听的文件或文件夹，支持正则 aggreateTimeout: 300, // 监听变化发生后300ms再去执行，默认300ms poll: 1000 // 判断文件是否发生变化，是通过不停询问系统指定文件是否发生变化，默认每秒1000次 &#125;&#125; webpack热更新 12345678910111213141516使用webpack-dev-server不刷新浏览器、不输出编译文件，而是放在内存里webpack.config.js中：module.exports = &#123; mode: 'development', devServer: &#123; contentBase: path.join(__dirname, 'dist'), hot: true &#125;&#125;package.json中：&#123; scripts: &#123; server: webpack-dev-server --open &#125;&#125; 123456789101112131415161718使用webpack-dev-middlewarewdm将webpack输出的文件传给服务端直接上代码：const express = require('express');const webpack = require('webpack');const WebpackDevMiddleware = require('webpack-dev-middleware');const app = express();const config = require('./webpack.config.dev.js');const compiler = webpack(config);app.use(WebpackDevMiddleware(compiler, &#123; publicPath: config.output.path&#125;))app.listen(3000, function() &#123; console.log('listen 3000');&#125;) 原理： 12345webpack compiler 编译生成bundle.jsHMR Server 将热更新的文件传给 HMR RuntimeBundle Server 提供文件浏览器访问HMR Runtime 注入到浏览器的bundle.js中，跟新文件变化bundle.js 构建输出的文件 此处缺少一张图 位置：/Users/aaa/Downloads/youdao-note-imgs 文件指纹 1234如何生成：Hash: 和整个项目的构建有关，只有项目文件修改，整个项目构建的hash值就会更改Chunkhash: 和webpack打包的chunk有关，不同的entry会生成不同的chunkhash值Contenthash: 根据文件内容来定义hash，文件内容不变，则Contenthash不变 1234567js文件指纹设置webpack.config.js中：mode: 'production',output: &#123; path: path.join(__dirname, 'dist'), filename: [name]_[chunkhash:8].js&#125; 1234567891011121314151617css文件指纹设置：安装依赖插件：npm i mini-css-extract-plugin --save-devwebpack.config.js中const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] &#125;] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;) ]&#125; 123456789101112131415161718192021图片、字体文件指纹设置：webpack.config.js中：module: &#123; rules: [&#123; test: /\\.png|jpg|gif|jpeg$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name]_[hash:8].[ext]' &#125; &#125; &#125;, &#123; test: /\\.woff|woff2|eot|ttf|otf$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name]_[hash:8].[ext]' &#125; &#125; &#125;]&#125; 占位符 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件相对路径 [folder] 文件所在的文件夹 [contenthash] 文件的内容hash，默认由md5生成 [hash] 文件内容的hash，默认由md5生成 [emoji] 一个随机的指代文件内容的emoji js html css 文件压缩 12js压缩webpack4 内置了uglifyjs-webpack-plugin, mode为production时，自动执行压缩操作 1234567891011121314151617181920212223html压缩安装依赖插件：npm i html-webpack-plugin --save-devwebpack.config.js中：const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, 'src/index.html'), filename: 'index.html', chunks: [index], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCss: true, minifyJs: true, removeComments: false &#125; &#125;) ]&#125; 12345678910111213141516css压缩安装依赖 npm i optimize-css-assets-webpack-plugin cssnano --save-devwebpack.config.js中：const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');module.exports = &#123; plugins: [ new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano'), cssProcessorPluginOptions: &#123; preset: ['default', &#123; discardComments: &#123; removeAll: true &#125; &#125;] &#125;, canPrint: true &#125;) ]&#125; 进阶篇 自动清理构建目录产物 1234通过package.json中的scripts清理scripts: &#123; build: rm -rf ./dist &amp;&amp; webpack&#125; 123456789通过插件 clean-webpack-plugin安装依赖： npm i clean-webpack-plugin --save-devwebpack.config.js中：const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; plugins: [ new CleanWebpackPlugin() ]&#125; 自动补齐css3前缀 1234567891011121314151617181920212223安装依赖 npm i postcss-loader autoprefixer --save-devwebpack.config.js中module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use ['style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; [require('autoprefixer')] &#125; &#125;] &#125;] &#125;&#125;package.json中&#123; \"browserslist\": [ \"last 2 version\", \"&gt;1%\", \"ios 7\" ]&#125; px自动转为css 1234567891011121314151617181920212223242526通过使用px2rem-loader、lib-flexiblepx2rem-loader: 将px转为remlib-flexible: 时时计算根元素字体大小安装依赖 npm i px2rem-loader --save-devnpm i lib-flexible --savewebpack.config.js中module.exports = &#123; module: &#123; rules: [&#123; test: /\\.css$/, use ['style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () =&gt; [require('autoprefixer')] &#125; &#125;, &#123; loader: 'px2rem-loader', options: &#123; remUni: 75, remPricision: 8 &#125; &#125;] &#125;] &#125;&#125; 静态资源内联 123456依赖于raw-loader意义：代码层面：页面框架到初始化脚本；上报相关打点；css内联避免页面闪动请求层面：减少HTTP网络请求小图片或者字体内联，用url-loader raw-loader 没有使用成功5. 多页面应用编译 12345通用方案：动态获取entry和设置 html-webpack-plugin数量依赖于 glob 安装依赖 npm i glob --save-dev具体遍历封装参考 https://github.com/userlvqingke/testEmpty webpack.pro.js soucemap应用 123456webpack.config.js中module.exports = &#123; module: &#123; devtool: 'souce-map' // 值有很多，相见webpack开发文档 &#125;&#125; 提取页面公共资源 1234基础库分离思路：将react、react-dom基础包通过cdn引入，不打入bundle.js中使用 html-webpack-externals-plugin 123456789101112131415161718webpack3中用到 CommonsChunkPluginwebpack4中用到 SplitChunksPluginwebpack.config.js中module.exports = &#123; optimization: &#123; splitChunks: &#123; minSize: 0 // 公共模块最小大小 cacheGroups: &#123; commons: &#123; name: 'commons', chunks: 'all', minChunks: 2 // 几处共用到 &#125; &#125; &#125; &#125;&#125; tree shaking(摇树优化) 1234概念：1个模块可能有很多方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle里面去，tree shaking就是只把用到的方法打入bundle中，没有用到的方法会在uglify阶段被删除掉使用：webpack默认支持，在.babelrc中设置modules: false即可 mode: production 默认开启要求必须是ES6语法 scope hoisting 原理 123456现象：构建后代码存在大量闭包代码问题：大量函数闭包包裹代码，导致体积增大（模块越多越明显）运行代码时，创建的函数作用域变多，内存开销变大原理：将所有模块的代码按照引入顺序放在一个函数作用域，然后适当命名一些变量以防止变量名冲突对比：通过scope hoisting可以减少函数声明代码和内存开销 代码分割和动态import 12345678910懒加载js脚本的方式：CommonJS: require.ensureES6:动态import（目前原生还没有支持，需要babel转换）安装依赖插件：npm i @babel/plugin-syntax-dynamic-import --save-dev.babelrc中：&#123; plugins: [\"plugin-syntax-dynamic-import\"]&#125; 在webpack中使用eslint 12345678910111213141516171819202122232425262728293031323334353637安装依赖:npm i eslint-loader --save-devwebpack.config.js中：module.exports = &#123; module: &#123; rules: [&#123; test: /\\.js$/, use: 'eslint-loader' &#125;] &#125;&#125;创建.eslint文件\"use strict\";module.exports = &#123; root: true, env: &#123; node: true, es6: true &#125;, parserOptions: &#123; ecmaVersion: 2018, sourceType: 'module' &#125;, globals: &#123; Atomics: 'readonly', SharedArrayBuffer: 'readonly' &#125;, rules: &#123; indent: ['error', 4], semi: ['off', \"always\"], \"multiline-comment-style\": ['off', \"always\"] &#125;, extends: [ 'standard' ],&#125; 1234制定团队的ESLint规范不重复造轮子，基于eslint:recommend进行改进能够帮助发现代码错误的规则，全部开启帮助团队保持代码风格的统一，而不是限制开发体验 webpack打包组件和基础库 1参考 https://github.com/userlvqingke/-jacklv-js-demo webpack 实现ssr打包 123456这个现在不做具体尝试渲染：HTML + CSS + JS + Data --&gt;渲染后的html服务端： 所有模版资源都存储在服务端 内网机器拉取数据更快 一个html返回所有数据 *** 客户端渲染 服务端渲染 请求 多个请求（html和数据等） 1个请求 加载过程 html和数据串行加载 1个请求返回Html和数据 渲染 前端渲染 服务端渲染 可交互 图片等静态资源加载完毕，JS逻辑执行完成可交互 14.优化构建时命令行的显示日志 12345678910安装依赖插件：friendly-errors-webpack-pluginnpm i friendly-errors-webpack-plugin --save-devwebpack.config.js中const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin')module.exports = &#123; plugins: [ new FriendlyErrorsWebpackPlugin() ] stats: 'errors-only'&#125; 构建异常和中断处理 12345构建完成后，输入echo $?获取错误码webpack4之前的版本构建失败不会抛出错误码（error code）Nodejs 中process.exit规范 0标识成功，回调函数中err为null 非0标识失败，回调函数中err不为null，err.code 是要传给exit的值 1234567891011121314151617181920212223242526webpack.config.js中 webpack4module.exports = &#123; plugins: [ function() &#123; this.hook.done.tap('done', stats =&gt; &#123; if (stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf('--watch') == -1) &#123; console.log('build error') process.exit(1) &#125; &#125;) &#125; ]&#125;webpack.config.js中 webpack3module.exports = &#123; plugins: [ function() &#123; this.plugin('done', stats =&gt; &#123; if (stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf('--watch') == -1) &#123; console.log('build error') process.exit(1) &#125; &#125;) &#125; ]&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://userlvqingke.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://userlvqingke.github.io/tags/webpack/"},{"name":"构建工具","slug":"构建工具","permalink":"https://userlvqingke.github.io/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo 操作指南","date":"2020-06-11T10:52:52.000Z","path":"hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"博客","slug":"博客","permalink":"https://userlvqingke.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"https://userlvqingke.github.io/tags/hexo/"}]}]